[{"content":"前言 此系列文章是《Digital Design and Computer Architecture: RISC-V Edition》的读书笔记。\n数字抽象的深层含义 数字电路使用离散值，而物理值一般是连续的，所以电路设计者要想办法把离散值和连续值对应起来。\n供电电压 零伏特电压一般指的是接地（GND）。从上世纪 70 年代起，供电电压从 5V 降到了 1.2V 以下。\n逻辑电平 逻辑电平是指数字电路中电信号的电压水平，用于表示逻辑状态。在数字电路中，通常将电压分为两个离散的状态，分别代表逻辑值 0 和逻辑值 1。\n噪声裕度 表示可以容忍的电压差值：\n$$ NM_{L} = V_{IL} - V_{OL}$$ $$ NM_{H} = V_{OH} - V_{IH}$$\n直流传输特性 将输入电压作为自变量，将输出电压作为因变量，抽象出一个函数。其形成的图像很有特点，叫作直流传输特性（DC Transfer Characteristics）。图像请参阅原书。\n静态电路法则 静态电路法则要求，在给定逻辑上有效的输入情况下，每个电路元件都将产生逻辑上有效的输出。\n为了提高生产力，诞生了四个逻辑家族：\nTTL CMOS LVTTL LVCMOS 习题 ","date":"2024-02-02T00:00:00Z","image":"https://kyocius.github.io/p/arch-book-1/header_hueaa4c8e5fd7a5595d1ecd775a7c5eb94_634924_120x120_fill_box_smart1_3.png","permalink":"https://kyocius.github.io/p/arch-book-1/","title":"数电与计算机体系结构 01：入门"},{"content":"前言 笔者撰写本文时还在上大一，数据结构基础几乎为零，所以会有一些可笑的问题和不合时宜的吐槽。\n本文尝试解答书后附加题，有的章节太简单就略过了。\n练习10：字符串数组和循环 如何使用 ,（逗号）字符来在for循环的每一部分中，;（分号）之间分隔多条语句？ 1 for (i = 0, j = 10; i \u0026lt; 10; i++, j--) 查询 NULL 是什么东西，看看它会打印出什么？ 在 C 语言中，NULL 是一个宏定义，通常用于表示指针不指向任何有效的对象或地址。NULL 的确切定义可能因编译器和平台而异，但通常它被定义为 (void *)0，即一个转换为 void 指针类型的零值。\n当你尝试打印一个指向 NULL的指针时，结果会取决于你是如何打印它的。在 C 语言中，如果你使用 %p 格式化标志（用于打印指针地址）和 printf 函数，通常会打印出一个表示空指针的值，通常是 (nil) 或者 0x0，具体取决于编译器和平台。\n看看你是否能在打印之前将 states 的一个元素赋值给 argv 中的元素，再试试相反的操作？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { char *states[] = {\u0026#34;California\u0026#34;, \u0026#34;Oregon\u0026#34;, \u0026#34;Washington\u0026#34;, \u0026#34;Texas\u0026#34;}; // 将states的一个元素赋值给argv的一个元素 // 注意：这通常不是个好主意，因为argv通常不应被修改 if (argc \u0026gt; 1) { argv[1] = states[0]; printf(\u0026#34;argv[1] is now %s\\n\u0026#34;, argv[1]); } // 将argv的一个元素赋值给states的一个元素 states[0] = argv[0]; printf(\u0026#34;states[0] is now %s\\n\u0026#34;, states[0]); return 0; } 练习16：结构体和指向它们的指针 如何在栈上创建结构体，就像你创建任何其它变量那样？ 如何使用 x.y 而不是 x-\u0026gt;y 来初始化结构体？ 对于前两个问题其实非常好解答。只要把变量 x 设置成非指针即可。\n如何不使用指针来将结构体传给其它函数？ C 语言不可能不使用指针传递结构体本身。所以这道题的意思就浅显地指，把参数的 * 去掉你会不会\u0026hellip;\n详细代码请见：GitHub\n练习17：堆和栈的内存分配 对于现在你们这些年轻人来说，编程简直太容易了。如果你玩玩 Ruby 或者 Python 的话，只要创建对象或变量就好了，不用管它们存放在哪里。\n理清内存最简单原则：如果你的变量并不是从 malloc 中获取的，也不是从一个从 malloc 获取的函数中获取的，那么它在栈上。\nstrncpy 有什么设计缺陷？ 1 char *strncpy(char *dest, const char *src, size_t n) strcpy 函数不会向 dest 追加 \\0，也就是字符串没有了结束，可能会造成内存非法访问。\nC 如何打包结构体？结构体添加一些字段之后的新大小？ 在 C 语言中，结构体的默认对齐方式通常是按照结构体成员中占用内存最大的数据类型进行对齐。这被称为“最大成员对齐”或“自然对齐”。\n结构体的总大小是其最大对齐成员的大小的整数倍。\n练习18：函数指针 函数指针编写窍门：\n编写一个普通的函数声明：int callme(int a, int b) 将函数用指针语法包装：int (*callme)(int a, int b) 将名称改成指针名称：int (*compare_cb)(int a, int b) 我们可以使用 typedef 来简化函数指针以便于传参：\n1 typedef int (*compare_cb)(int a, int b) 如此，在另一个函数中，我们就能将 compare_cb 作为类型传递：\n1 int *bubble_sort(int *numbers, int count, compare_cb cmp) 将错误的函数传给 compare_cb，并看看 C 编辑器会报告什么错误？ 类似于 \u0026ldquo;assignment from incompatible pointer type\u0026rdquo; 或 \u0026ldquo;incompatible types in assignment\u0026rdquo; 的错误消息。\n将 NULL 传给它，看看程序中会发生什么。然后运行 Valgrind 来看看它会报告什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; void myFunction(int *ptr) { if (ptr != NULL) { // 在这里解引用非空指针 *ptr = 42; } } int main() { int *nullPointer = NULL; // 将 NULL 传递给函数指针 myFunction(nullPointer); return 0; } Valgrind 的报错：\n1 2 3 4 ==12345== Invalid write of size 4 ==12345== at 0x80484A7: myFunction (example.c:6) ==12345== by 0x80484F4: main (example.c:14) ==12345== Address 0x0 is not stack\u0026#39;d, malloc\u0026#39;d or (recently) free\u0026#39;d 这个报告表明在 myFunction 函数的第 6 行发生了一个尝试写入大小为 4 的无效内存。\n练习32：双向链表 强烈建议 0 数据结构基础先去油管看一下印度老哥的双向链表教程：YouTube\n先在头文件中编写两个结构体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdlib.h\u0026gt; struct ListNode; typedef struct ListNode { struct ListNode *prev; struct ListNode *next; void *value; // 可以指向任何数据类型 } ListNode; typedef struct List { ListNode *first; ListNode *last; int count; } 然后预定义四个 List 的整体方法：\n1 2 3 4 List *List_create(); void List_destroy(List *list); void List_clear(List *list); void List_clear_destroy(List *list); 三个宏方法（不知道为什么要用宏）：\n1 2 3 4 5 #define List_count(A) ((A)-\u0026gt;count) #define List_first(A) ((A)-\u0026gt;first != NULL ? (A)-\u0026gt;first-\u0026gt;value : NULL) #define List_last(A) ((A)-\u0026gt;last != NULL ? (A)-\u0026gt;last-\u0026gt;value : NULL) 接下来预定义数据的操作方法：\n1 2 3 4 5 6 7 8 void List_push(List *list, void *value); void *List_pop(List *list); // 链表的头部插入与删除，命名风格来自于 Perl 语言 void List_unshift(List *list, void *value); void *List_shift(List *list); void *List_remove(List *list, ListNode *node); 定义 LIST_FOREACH 宏。书中说这是个常见的习语：\n1 2 3 #define LIST_FOREACH(L, S, M, V) ListNode *_node = NULL; \\ ListNode *V = NULL;\\ for(V = _node = L -\u0026gt; S; _node != NULL; V = _node = _node -\u0026gt; M) 这个宏利用了一个 for 循环，其中 _node 用于跟踪当前节点，V 用于表示当前节点。在每次迭代中，_node 被更新为下一个节点，从而实现链表遍历的封装。\n现在开始实现头文件的方法。在 list.c 中先完成 List 的整体方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;lcthw/list.h\u0026gt; List *List_create() { return calloc(1, sizeof(List)); } void List_destroy(List *list) { LIST_FOREACH(list, first, next, cur) { if (cur-\u0026gt;prev) free(cur-\u0026gt;prev) } free(list-\u0026gt;last); free(list); } void List_clear(List *list) { LIST_FOREACH(list, first, next, cur) { free(cur-\u0026gt;value); } } void List_clear_destroy(List *list) { List_clear(list); List_destroy(list); } 接下来实现数据的操作方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 void List_push(List *list, void *value) { ListNode *node = calloc(1, sizeof(ListNode)); check_mem(node); // 跳转到 error 标签 node-\u0026gt;value = value; if(list-\u0026gt;last == NULL) { list-\u0026gt;first = node; list-\u0026gt;last = node; } else { list-\u0026gt;last-\u0026gt;next = node; node-\u0026gt;prev = list-\u0026gt;last; list-\u0026gt;last = node; } list-\u0026gt;count++; error: return; } void *List_pop(List *list) { ListNode *node = list-\u0026gt;last; return node != NULL ? List_remove(list, node) : NULL; } void List_unshift(List *list, void *value) { ListNode *node = calloc(1, sizeof(ListNode)); check_mem(node); node-\u0026gt;value = value; if(list-\u0026gt;first == NULL) { list-\u0026gt;first = node; list-\u0026gt;last = node; } else { node-\u0026gt;next = list-\u0026gt;first; list-\u0026gt;first-\u0026gt;prev = node; list-\u0026gt;first = node; } list-\u0026gt;count++; error: return; } void *List_shift(List *list) { ListNode *node = list-\u0026gt;first; return node != NULL ? List_remove(list, node) : NULL; } void *List_remove(List *list, ListNode *node) { void *result = NULL; check(list-\u0026gt;first \u0026amp;\u0026amp; list-\u0026gt;last, \u0026#34;List is empty.\u0026#34;); check(node, \u0026#34;node can\u0026#39;t be NULL\u0026#34;); if(node == list-\u0026gt;first \u0026amp;\u0026amp; node == list-\u0026gt;last) { list-\u0026gt;first = NULL; list-\u0026gt;last = NULL; } else if(node == list-\u0026gt;first) { list-\u0026gt;first = node-\u0026gt;next; check(list-\u0026gt;first != NULL, \u0026#34;Invalid list, somehow got a first that is NULL.\u0026#34;); list-\u0026gt;first-\u0026gt;prev = NULL; } else if (node == list-\u0026gt;last) { list-\u0026gt;last = node-\u0026gt;prev; check(list-\u0026gt;last != NULL, \u0026#34;Invalid list, somehow got a next that is NULL.\u0026#34;); list-\u0026gt;last-\u0026gt;next = NULL; } else { ListNode *after = node-\u0026gt;next; ListNode *before = node-\u0026gt;prev; after-\u0026gt;prev = before; before-\u0026gt;next = after; } list-\u0026gt;count--; result = node-\u0026gt;value; free(node); error: return result; } 现在我们终于实现了双向链表上的所有操作。闹麻了，书上的实现方法感觉跟喂了 Poops 一样。\n研究双向和单向链表，以及什么情况下其中一种优于另一种。 单向链表内存小，性能好；双向链表功能强，比如逆序遍历。\n研究双向链表的限制。例如，虽然它们对于插入和删除元素很高效，但是对于变量元素比较慢。 双向链表更改一个节点意味着要修改两端的节点，这太地狱了。\n","date":"2024-01-23T00:00:00Z","image":"https://kyocius.github.io/p/clang-review/head_hub4c439e7083278e8ec7df601f4a86ed3_945835_120x120_fill_box_smart1_3.png","permalink":"https://kyocius.github.io/p/clang-review/","title":"笨方法学 C 附加题不完全解答"},{"content":" 本文翻译自托管在 GitHub 上的 2fsharp 开源项目\n译版仅发表在知乎和 本人博客 上，未经授权禁止转载\n这个教程是基于实例来讲解的，将会花费你 15-30 分钟的时间。\n你将会学到 F# 这门语言 80% 的特性！\n例 1：基本函数声明与实现 1 2 3 4 5 6 7 public int GiveMeTheLength(string input) { // 单行注释 var result = input.Length; /* 多行注释 */ return result; } 变成了\n1 2 3 4 5 let GiveMeTheLength(input) = // 单行注释 let result = input.Length (* 多行注释 *) result 所有东西都是默认为 public 的，除非你显式声明 private 修饰符。 关键字 var 变成了 let（不仅仅用来声明变量，还用来声明函数）。 你不再需要 return 关键字。函数的最后一行就是返回值。 不再需要花括号，使用 4 格（或者 2 格）缩进，就像 Python 一样。 不再需要分号来标志一行结束。 类型声明是可选的，除了极少数情况编译器无法推断类型。 单行注释和 C# 相同，但是多行注释使用括号而不是斜杠。 如果你想要声明类型，需要这样写：\n1 2 3 let GiveMeTheLength(input: string): int = let result: int = input.Length result 例 2：基本关键字和操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using System; class MainClass { void Main() { int exitCode = 0; if (incomingChar == Environment.NewLine) exitCode = 1; else if (!(incomingChar == String.Empty)) exitCode = 2; else if (incomingChar != \u0026#34;\\t\u0026#34; \u0026amp;\u0026amp; incomingChar.Length \u0026gt; 1) exitCode = 3; else exitCode = 4; Environment.Exit(exitCode); } } 变成了\n1 2 3 4 5 6 7 8 9 10 11 12 open System let mutable exitCode: int = 0 if incomingChar = Environment.NewLine then exitCode \u0026lt;- 1 elif not (incomingChar = String.Empty) then exitCode \u0026lt;- 2 elif (incomingChar \u0026lt;\u0026gt; \u0026#34;\\t\u0026#34; \u0026amp;\u0026amp; incomingChar.Length \u0026gt; 1) then exitCode \u0026lt;- 3 else exitCode \u0026lt;- 4 Environment.Exit(exitCode) using 关键字变成了 open 关键字。 if (x) foo(); else if (y) bar(); else baz(); 模式变成了 if x then foo() elif y then bar() else baz()，条件语句也不再需要圆括号。但是使用了新的关键字 then 和 elif。 初始赋值（只读常量）操作符是 =。如果你需要为这个元素重新赋值，你需要将它标记为 mutable 然后使用 \u0026lt;- 操作符。 操作符 = 变成了比较符（不再需要像 C# 那样使用双等号 == 了）。 操作符 != 变成了 \u0026lt;\u0026gt;。 操作符 ! 变成了 not。 操作符 \u0026amp;\u0026amp; 和 || 在 F# 不变。 不再需要提供 Main() 方法这样的入口函数, 直接在一个 .fsx 文件中编写逻辑或者使用最新的 .fs 文件中编写语句以满足 F# 编译器要求。 通常，上面的代码其实不需要使用 mutable，就像如下写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 open System let exitCode = if incomingChar = Environment.NewLine then 1 elif not (incomingChar = String.Empty) then 2 elif (incomingChar \u0026lt;\u0026gt; \u0026#34;\\t\u0026#34; \u0026amp;\u0026amp; incomingChar.Length \u0026gt; 1) then 3 else 4 Environment.Exit(exitCode) （这和 C# 中的三元操作符类似，但是可读性更高）\n例 3：基础集合 1 2 3 4 5 6 7 var intArray = new int[] { 1, 2, 3 }; var intList = new List\u0026lt;int\u0026gt;({ 4, 5, 6 }); IEnumerable\u0026lt;int\u0026gt; sequenceOfIntegers = intList; var dictionary = new Dictionary\u0026lt;int,string\u0026gt;() { { \u0026#34;One\u0026#34;, 1 }, { \u0026#34;Two\u0026#34;, 2 } } 变成了如下代码（其实你不需要声明类型，这里只是为了方便教学）：\n1 2 3 4 let intArray: array\u0026lt;int\u0026gt; = [| 1; 2; 3 |] let intList: List\u0026lt;int\u0026gt; = [ 4 ; 5 ; 6 ] let sequenceOfIntegers: seq\u0026lt;int\u0026gt; = intList let dictionary: IDictionary\u0026lt;string,int\u0026gt; = dict [ (\u0026#34;One\u0026#34;, 1); (\u0026#34;Two\u0026#34;, 2) ] 声明 Array/List/Dictionary 时，逗号变成了分号。 IEnumerable\u0026lt;T\u0026gt; 变成了 seq\u0026lt;'T\u0026gt;（Sequence 的缩写）。 你使用一个 dict 来初始化一个IDictionary\u0026lt;K,V\u0026gt; 集合，但是在 F# 中你将会更倾向于使用 Map\u0026lt;'K,'V\u0026gt; 因为它是可变的。 你可能也注意到了，泛型类型需要一个前缀单引号「\u0026rsquo;」\n例 4：代码块 1 2 3 4 5 6 7 8 9 10 11 try { TrySomething(someParam); } catch (SomeException ex) { if (SomeCondition(ex)) { DoSomethingElse(ex); throw new OtherException(); } else throw; } finally { MakeSureToCleanup(someParam); } 变成了\n1 2 3 4 5 6 7 8 9 10 11 12 13 try try TrySomething(someParam) with | :? SomeException as ex -\u0026gt; if SomeCondition(ex) then DoSomethingElse(ex) raise OtherException else reraise() finally MakeSureToCleanup(someParam) catch 变成了 with 关键字。 throw X; 语句变成了 raise X，然后 throw; 变成了调用 reraise() 函数。 但是，没有 try-with-catch 块！F# 只有 try-with 和 try-finally 块。所以我们只能用两个 try 嵌套。 你可能会想，这是 F# 的缺陷，但其实完整的 try-catch-finally 块很少用，尤其是有了 using 关键字：\n1 2 3 4 using (var reader = new StreamReader(someFile)) { DoStuff(reader); } 这变成了\n1 2 use reader = new StreamReader(someFile) DoStuff(reader) 使用 use 就不再需要嵌套代码块了。 资源会自动释放（和 C# 的 using 相同）。 例 5：避免 Null 和忽略 1 2 3 4 5 6 7 8 void Check(SomeType someParam1, SomeType someParam2) { if (someParam1 != null) stringBuilder.Append(someParam1.ToString()); if (someParam2 != null) stringBuilder.Append(String.Empty); } 变成了\n1 2 3 4 5 6 7 8 9 10 11 12 let Check(someParam1: Option\u0026lt;SomeType\u0026gt;, someParam2: Option\u0026lt;SomeType\u0026gt;): unit = match someParam1 with | Some(someValue) -\u0026gt; // like \u0026#39;as\u0026#39; in C#, you cast and want the value let str = someValue.ToString() ignore(stringBuilder.Append(str)) | None -\u0026gt; () match someParam2 with | Some(_) -\u0026gt; // like \u0026#39;is\u0026#39; in C#, you don\u0026#39;t care about the value stringBuilder.Append(String.Empty) |\u0026gt; ignore | _ -\u0026gt; () 在 C# 中你经常会到处写判空检查（没有编译时安全）。在 F# 中，你将使用更安全的 Option\u0026lt;T\u0026gt; 类型（与Nullable\u0026lt;T\u0026gt; 类似但是更棒）和 match 表达式（模式匹配）。\n当你不想返回任何东西时，在 C# 你会写 void 表示没有声明类型。但是在 F# 中你需要返回一个特殊的类 unit，它的默认值为 ()。 一个 match-with 代码块基本上和 switch 代码块类似，但是更加简洁明了，因为它包含了 Casting（SomeValue） 这里有三个方式来实现忽略： 比方说，我们不关心 Append() 函数的返回值，在 C# 中我们就直接忽略，但是在 F# 中我们需要显式地忽略它，使用 ignore() 这个魔法方法。 Match 表达式的下划线：它就像 C# 的 switch 中的 default 分支。 在 Some(_) 中的下划线表示，我们想保证一个值不是空，但我们又不关心它的具体值（就像 C# 中的 is 操作符）。 管道操作符：ignore(x) 与 x |\u0026gt; ignore 等价。 例 6：类型 下面这个类使用 F# 就简单很多。\n（译者注：其实可以使用 C# 6.0 的自动完成属性或者 C# 9.0 的记录类）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Foo { public Foo (int bar, string baz) { this.bar = bar; this.baz = baz; } readonly int bar; public int Bar { get { return bar; } } readonly string baz; public string Baz { get { return baz; } } } static class FooFactory { static internal Foo CreateFoo() { return new Foo(42, \u0026#34;forty-two\u0026#34;); } } 在 F# 中就一行：\n1 2 3 4 5 type Foo = { Bar: int; Baz: string } module FooFactory = let internal CreateFoo () = { Bar = 42; Baz = \u0026#34;forty-two\u0026#34; } 由此可见:\n没有动作行为的类（就像上面的 Foo 类）叫作「记录类 Record」，长得像 C# 的结构体但是它们依然是引用类型，并且被保存在堆上。记录类是不可变的。也就是说，一旦你创建它们，就不能再修改它们的值了。 静态类变成了「modules」，如上 FooFactory 类。 在 F# 中，不需要使用 new 关键字，除非这个类实现了 IDisposable 接口。 例 7：函数的顺序很重要，循环依赖是万恶之源 作为 C# 开发者，你当然知道下面的代码可以通过编译：\n1 2 3 4 5 6 7 8 9 10 11 12 13 static class Foo { static void Bar() { if (Baz()) Bar(); } static bool Baz() { return false; } } 理所应当！下面的代码也可以通过编译：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static class Foo1 { public static void Bar() { } static void Baz() { Foo2.Baz(); } } static class Foo2 { static void Bar() { Foo1.Bar(); } public static void Baz() { } } 也许你明白我说到哪里了。\n后一段 C# 代码可以通过编译，是因为 C# 允许循环依赖（Circular Dependencies）。\n但是这句话半对半错，因为在 C# 中循环依赖是合法的，但是在 .NET 程序集里不合法。如果程序集 A 依赖于程序集 B，你不能从 A 引用 B。\n这个模块性原则将会阻止你写出上面的代码，因为在未来你将不能将它们分为两个程序集（你不能将 Foo1 放进一个程序集里，然后把 Foo2 放进另一个程序集，因为在 .NET 中这并不合法）。\n之后，你需要了解的是，在 F# 中，即使在同一程序集里，循环依赖也不合法！\n通过强制你在类型 B 之前声明 类型 A，防止你在之后的函数中调用前面的函数时出错。\n因此，下面的 F# 编译时会报错：\n1 2 3 4 5 6 7 8 9 10 11 12 13 module Foo1 = let Bar() = () let Baz() = Foo2.Baz() module Foo2 = let Bar() = Foo1.Bar() let Baz() = () 为什么呢？来看看它的报错：\nError FS0039: The value, namespace, type or module \u0026lsquo;Foo2\u0026rsquo; is not defined. (Referring to Foo1.Baz implementation.) 这个报错是不能修复的，除非我们直接停止使用循环依赖。\n（还有一些特殊情况，比如使用 via 和 rec 关键字，但是在本教程中并不会讲解，因为太高级了）\nF# 编译器严格限制了我们不能循环依赖，这意味着如果函数 A 调用了函数 B，那么函数 B 就必须在 A 之前声明\n（如果这两个函数在同一个文件中，那么函数 B 就是在函数 A 上面；如果这两个函数在同一 F# 工程下不同文件中，那么 B.fs 必须比 A.fs 早列出）\n因此，下面的代码也不会通过编译：\n1 2 3 4 5 6 7 module Foo = let Bar() = if Baz() then Bar() let Baz(): bool = false 它抛出了如下错误：\nError FS0039: The value or constructor \u0026lsquo;Baz\u0026rsquo; is not defined. (Referring to Foo.Bar implementation.) Error FS0039: The value or constructor \u0026lsquo;Bar\u0026rsquo; is not defined. (Referring to Foo.Bar implementation.) 正如我们刚刚学到的，这更容易解决；只要先声明 Baz 即可。\n而为了让一个函数能够调用自己（在某种程度上，它也是一个循环依赖），我们使用 rec 关键字（意思就是「递归」)：\n1 2 3 4 5 6 7 module Foo = let Baz(): bool = false let rec Bar() = if Baz() then Bar() 例 8：委托、匿名函数···我的老天爷！ 在 C# 的早期版本中，需要通过委托类型和匿名函数传递函数。请看下面有 4 种组合的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 static class SomeOldCsharpClass { delegate void ProcedureWithNoReturnValueAndNoArguments(); static void DelegateReception1(ProcedureWithNoReturnValueAndNoArguments dlg) { dlg.Invoke(); } static void SendingAnonymousMethodAsDelegate1() { DelegateReception1(delegate () { Console.WriteLine(\u0026#34;hello 1\u0026#34;); }); } delegate void ProcedureWithNoReturnValueAndOneArg(string foo); static void DelegateReception2(ProcedureWithNoReturnValueAndOneArg dlg) { string bar = \u0026#34;baz\u0026#34;; dlg.Invoke(bar); } static void SendingAnonymousMethodAsDelegate2() { DelegateReception2(delegate (string foo) { Console.WriteLine(\u0026#34;hello 2 \u0026#34; + foo); }); } delegate int FunctionWithOneReturnValueAndNoArguments(); static void DelegateReception3(FunctionWithOneReturnValueAndNoArguments dlg) { int result = dlg.Invoke(); } static void SendingAnonymousMethodAsDelegate3() { DelegateReception3(delegate () { Console.WriteLine(\u0026#34;hello 3\u0026#34;); return 3; }); } delegate long FunctionWithOneReturnValueAndOneArg(double foo); static void DelegateReception4(FunctionWithOneReturnValueAndOneArg dlg) { double bar = 4.0; long result = dlg.Invoke(bar); } static void SendingAnonymousMethodAsDelegate4() { DelegateReception4(delegate (double foo) { Console.WriteLine(\u0026#34;hello 4 \u0026#34; + foo); return 4; }); } } 但后来新版本的 C# 出现了更优雅的方式（得益于局部函数）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 static class SomeNewCsharpClass { static void SendingAnonymousMethodAsDelegate1() { void DelegateReception1(Action dlg) { dlg.Invoke(); } DelegateReception1(() =\u0026gt; { Console.WriteLine(\u0026#34;hello 1\u0026#34;); }); } static void SendingAnonymousMethodAsDelegate2() { void DelegateReception2(Action\u0026lt;string\u0026gt; dlg) { string bar = \u0026#34;baz\u0026#34;; dlg.Invoke(bar); } DelegateReception2((string foo) =\u0026gt; { Console.WriteLine(\u0026#34;hello 2 \u0026#34; + foo); }); } static void SendingAnonymousMethodAsDelegate3() { void DelegateReception3(Func\u0026lt;int\u0026gt; dlg) { int result = dlg.Invoke(); } DelegateReception3(() =\u0026gt; { Console.WriteLine(\u0026#34;hello 3\u0026#34;); return 3; }); } static void SendingAnonymousMethodAsDelegate4() { void DelegateReception4(Func\u0026lt;double, long\u0026gt; dlg) { double bar = 4.0; long result = dlg.Invoke(bar); } DelegateReception4((double foo) =\u0026gt; { Console.WriteLine(\u0026#34;hello 4 \u0026#34; + foo); return 4; }); } } 最有趣的改进就是 .NET 预定义的 Action 和 Func 类型，以及 Lambda 表达式。\n好消息是在 F# 中，函数是一等公民。因此代码更加简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 module SomeFsharpModule = let SendingAnonymousMethodAsDelegate1() = let DelegateReception1(dlg: unit-\u0026gt;unit) = dlg() DelegateReception1(fun _ -\u0026gt; Console.WriteLine(\u0026#34;hello 1\u0026#34;) ) let SendingAnonymousMethodAsDelegate2() = let DelegateReception2(dlg: string-\u0026gt;unit) = let bar = \u0026#34;baz\u0026#34; dlg(bar) DelegateReception2(fun bar -\u0026gt; Console.WriteLine(\u0026#34;hello 2 \u0026#34; + bar) ) let SendingAnonymousMethodAsDelegate3() = let DelegateReception3(dlg: unit-\u0026gt;int) = let result = dlg() () DelegateReception3(fun _ -\u0026gt; Console.WriteLine(\u0026#34;hello 3\u0026#34;) 3 ) let SendingAnonymousMethodAsDelegate4() = let DelegateReception4(dlg: double-\u0026gt;int64) = let bar = 4.0 let result = dlg(bar) () DelegateReception4(fun bar -\u0026gt; Console.WriteLine(\u0026#34;hello 4 \u0026#34; + bar.ToString()) int64(4) ) 正如你所看到的，BCL 的 System.Function 和 System.Action 变成了原生 F# 语法。\n通过 -\u0026gt; 符号来表示参数和返回值，例如 TArg1-\u0026gt;TResult。请记住，void 在 F# 中是 unit。\n同样重要的是，C# 的 (...) =\u0026gt; { ... } 变成了 fun ... -\u0026gt; ...\n例 9：元组、局部应用以及柯里化 如果你没有做过函数式编程，你可能会对其中的一些概念感到害怕，比如「局部应用 Partial Application」「柯里化 Currification」。\n但事实是，它们并不是那么复杂的概念。为了正确解释它们，我们需要先解释元组，以及为什么不建议在 F# 中滥用它们。\n（事实上，你不能用元组来使用局部应用！稍后将详细介绍）\n让我们先看看下面这段使用 out 参数的 C# 代码：\n1 2 3 4 5 6 int anInteger; if (int.TryParse(someString, out anInteger)) { DoSomethingWithAnInteger(anInteger); } else { DoSomethingElse(); } 如果你尝试将上面的 C# 代码转译成 F#，你首先会有一个疑问：我们怎样声明一个变量但不给它赋值呢？相信我，F# 是不可能做到的。\n你可能会想到先随便给变量 anInteger 赋一个值，反正最后会被 TryParse() 方法覆写。但是这种方式不够优雅，尤其是把变量标记为 mutable，不符合 F# 的语言习惯。\n最好的方法是使用「积极模式 Acitve Pattern」——将上面多个函数转换成一个函数，并且同时虚拟地返回两个值：\n1 2 3 match int.TryParse(someString) with | (true, anInteger) -\u0026gt; DoSomethingWithAnInteger(anInteger) | (false, _) -\u0026gt; DoSomethingElse() 积极模式为 F# 编译器提供了语法糖，将 bool TryParse(string,out int) 转换成了类似 (bool,int) TryParse(string) 的函数，而 (bool,int) 是一个元组！\n所以在 F# 中，创建任意长度的元组是很容易的事情，不需要使用 System.Tuple\u0026lt;X,Y,...\u0026gt;。\n这让我想起了新版本 C# 对于元组的改进——你可以在函数的签名里使用元组而不需要用 Tuple。\n来检查一下我说的是什么意思吧。这是 C# 的老式写法：\n1 2 3 4 5 6 7 8 bool ReceiveTuple(Tuple\u0026lt;string,int\u0026gt; aTuple) { var counter = aTuple.Item2++; Console.WriteLine(aTuple.Item1); var newTuple = new Tuple\u0026lt;string,int\u0026gt;(aTuple.Item1, counter) ReceiveTuple(newTuple); return true; } 如果我们想要一个变量指向这个函数，它的类型就应是 Func\u0026lt;Tuple\u0026lt;string,int\u0026gt;,bool\u0026gt;。\n新式的 C# 写法（会被编译成 ValueTuple\u0026lt;X,Y,...\u0026gt;）：\n1 2 3 4 5 6 7 8 bool ReceiveTuple((string str, int i) aTuple) { var counter = aTuple.i++; Console.WriteLine(aTuple.str); var newTuple = (aTuple.str, counter); ReceiveTuple(newTuple); return true; } 现在我们有了一个指向这个函数的变量，它的类型是 Func\u0026lt;ValueTuple\u0026lt;string,int\u0026gt;,bool\u0026gt;。\n使用 F#：\n1 2 3 4 5 6 let rec ReceiveTuple(str: string, i: int) = let counter = i + 1 Console.WriteLine(str) let newTuple = (str, counter) ReceiveTuple (newTuple) true 在这种情况下，你引用这个函数的 F# 类型是 string*int-\u0026gt;bool；所以我们学到了一个新的符号：星号「*」在其它语言里代表指针，但在 F# 中它只是元组中类型的分隔符。\n你是否注意到元组是如何融入到 F# 中那些看似正常的参数中的？事实上，本指南到现在为止，我们在 F# 中写的所有接收多参的函数，实际上都在使用元组。不用元组能在 F# 中写出的上述方法吗？当然可以，只是省略了逗号：\n1 2 3 4 5 let rec ReceiveNonTuple (str: string) (i: int) = let counter = i + 1 Console.WriteLine(str) ReceiveNonTuple str counter true 函数 ReceiveTuple 和 ReceiveNonTuple 之间有什么区别？两者都接收相同数量的参数，并且具有相同的类型。但是，第一个函数的参数是 F# 元组，而第二个函数的参数则是以 F# 语言惯用方式声明的（以「柯里化」的形式）。\n为什么后者在 F# 中更符合语言习惯？因为 ReceiveTuple 不能用于局部应用，而ReceiveNonTuple 可以，因为它使用的是「柯里化」风格。在这种情况下，函数的类型不是 string*int-\u0026gt;bool，而是 (string-\u0026gt;int)-\u0026gt;bool。\n那为什么 (string-\u0026gt;int)-\u0026gt;bool 比 string*int-\u0026gt;bool 更好呢？\n后者允许与 C# 的互操作（因为这是以 CIL 级别传递参数的方式），但前者允许以非常直接和简洁的方式进行局部应用（我们将在后面看到，部分应用在 C# 中也是可能的，但方式非常复杂，可读性/维护性很差）。\n因此，不再多说，让我们看看一个非常简单的部分应用的例子。假设我们想创建一个乘法函数，接收两个整数并返回一个整数：\n1 2 let Multiply (x: int) (y: int): int = x * y 现在，如果我们想写一个函数将一个数字的值增加一倍，而不需要重复乘法函数的任何实现细节，我们可以简单地这样写：\n1 2 let Double (x: int): int = Multiply 2 当我们只向函数 Multiply 传递一个参数时会发生什么？\n让我们看看它的原始签名：(int-\u0026gt;int)-\u0026gt;int。「柯里法则」告诉我们，在类型表达式中使用小括号实际上是不需要的（或者把它们放在其他地方会得到一个等价的表达式）。这意味着我们也可以这样写 int-\u0026gt;int-\u0026gt;int 或者这样写 int-\u0026gt;（int-\u0026gt;int）。因此，向一个原本接收两个参数的函数只传递一个参数，实际上会导致返回另一个函数。\n我们可以这样更好地理解它：\n1 2 3 4 let Double (x: int): int = let doubleFunc = Multiply 2 let result = doubleFunc x result 或者这样（冗长的类型声明）：\n1 2 3 4 let Double (x: int): int = let doubleFunc: int-\u0026gt;int = Multiply 2 let result: int = doubleFunc x result 这是一个非常简单的例子，也许能让你明白局部应用的强大之处。但它是函数式编程中的依赖注入等操作的基础。随着时间的推移，你可能只会掌握它所带来的灵活性，但至少我们已经可以向你展示它在 F# 中的简单性。在 C# 中，我们只能这样来实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static Func\u0026lt;int, Func\u0026lt;int, int\u0026gt;\u0026gt; Multiply() { return (x) =\u0026gt; { (y) =\u0026gt; { x * y; }; }; } static Function\u0026lt;int,int\u0026gt; Double() { return Multiply().Invoke(2); } static int Main() { var someInt = 3; return Double().Invoke(someInt); } 你的大脑能转过弯儿来吗？对我来说，这比阅读 F# 代码难理解多了。\n关于局部应用及其用处的最后说明：你使用 F# 的时间越长，你就会意识到局部应用实际上是一种简化的依赖注入/控制反转（DI / IoC）方式，详见《局部应用就是依赖注入》一文。\n例 10：字符串插值 在早期的 C# 版本中，你需要这样写：\n1 var aStringToShowToTheUser = String.Format(\u0026#34;Hello {0}, I see you are {1} years old\u0026#34;, name, age); 这有两个问题：在大型代码库中，许多变量和元素被包含在一个字符串中，我们索引了一个没有提供的变量（例如 {2}）很容易发生，或者我们提供的变量没有隐式转换为字符串。\n在 F# 中是这样的：\n1 let aStringToShowToTheUser = sprintf \u0026#34;Hello %s, I see you are %i years old\u0026#34; name age 哪个更好？\n如果你提供的参数少于（或多于）在字符串中插值所需的参数，你将得到一个编译器错误，而不是在运行时出现异常。 你需要通过 % 后面的字母来指定字符串中元素的类型，如果它与为同一位置提供的元素的类型不匹配，那么你会得到一个编译器错误（而不是一个无用的元素字符串表示）。 你需要更少的小括号（参见本指南中的最后一个例子）。 例 11：异步代码 一段简单的 C# 异步代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 static class MainClass { public class Toast { public bool IsYummy() { return true; } } static async Task\u0026lt;Toast\u0026gt; ToastBreadAsync() { var task = Task.Run(() =\u0026gt; new Toast() ); return await task; } static void ApplyButter(Toast toast) { /* TODO */ } static void ApplyJam(Toast toast) { /* TODO */ } static async Task\u0026lt;Toast\u0026gt; MakeToastWithButterAndJamAsync() { var toast = await ToastBreadAsync(); ApplyButter(toast); ApplyJam(toast); return toast; } public static async Task Main(string[] args) { Console.WriteLine(\u0026#34;Hello World!\u0026#34;); var toast = await MakeToastWithButterAndJamAsync(); Console.WriteLine(\u0026#34;Bye World!\u0026#34; + toast.IsYummy()); } } } 在 F# 中变成了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 type Toast() = member this.IsYummy() = true let ToastBread(): Async\u0026lt;Toast\u0026gt; = async { return Toast() } let ApplyButter(toast) = () //TODO let ApplyJam(toast) = () //TODO let MakeToastWithButterAndJam() = async { let! toast = ToastBread() ApplyButter(toast) ApplyJam(toast) return toast } [\u0026lt;EntryPoint\u0026gt;] let main(argv) = Console.WriteLine(\u0026#34;Hello World!\u0026#34;) let toast = MakeToastWithButterAndJam() |\u0026gt; Async.RunSynchronously Console.WriteLine (\u0026#34;Bye world!\u0026#34; + (toast.IsYummy().ToString())) 0 // return an integer exit code 关键不同点：\n在 C# 中，当你调用一个异步方法时，你会得到一个 Task\u0026lt;T\u0026gt; 对象，它代表正在进行的工作，并且已经被启动。但在 F# 中，Job 是由一个 Async\u0026lt;'T\u0026gt; 对象表示的，它还没有被启动（你可以在之后决定如何启动它；例如，在上面例子中，它用 Async.RunSynchronously 来启动）。 在 F# 的 let 语句后面加上惊叹号 ! 等价于 C# 的 await。 在 C# 中，你将计算量大的同步方法包装在 Task.Run() 中，将其转换为异步方法。在 F# 中，你只需用 async{} 块（一个计算表达式）来包装它们。 如果我们稍微改变上面的 C# 代码，引入非泛型 Task 对象和并行化（假设我们有两个烤面包机）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class Ingredients { } public class Toast { public Toast(Ingredients i) { } } static async Task\u0026lt;Toast\u0026gt; ToastBreadAsync(Ingredients i) { var task = Task.Run(() =\u0026gt; new Toast(i) ); return await task; } static async Task\u0026lt;Toast[]\u0026gt; Make2ToastsAsync(Ingredients i) { var toast1 = ToastBreadAsync(i); var toast2 = ToastBreadAsync(i); return await Task.WhenAll(toast1, toast2); } static async Task MakeToastsAsync() { var i = await GatherIngredients(); await Make2ToastsAsync(i); } public static async Task\u0026lt;Ingredients\u0026gt; GatherIngredients() { return await Task.FromResult(new Ingredients()); } public static async Task Main(string[] args) { Console.WriteLine(\u0026#34;Hello World!\u0026#34;); await MakeToastsAsync(); Console.WriteLine(\u0026#34;Bye World!\u0026#34;); } 在 F# 中，这变成了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 type Ingredients () = class end type Toast (i: Ingredients) = class end let ToastBread(i): Async\u0026lt;Toast\u0026gt; = async { return Toast(i) } let GatherIngredients () = async { return Ingredients() } let Make2Toasts(i) = async { let twoJobs: List\u0026lt;Async\u0026lt;Toast\u0026gt;\u0026gt; = [ToastBread(i); ToastBread(i)] let! _ = Async.Parallel(twoJobs) return () } let MakeToasts() = async { let! i = GatherIngredients() do! Make2Toasts(i) } [\u0026lt;EntryPoint\u0026gt;] let main(argv) = Console.WriteLine(\u0026#34;Hello World!\u0026#34;) MakeToasts() |\u0026gt; Async.RunSynchronously Console.WriteLine(\u0026#34;Bye world!\u0026#34;) 0 // return an integer exit code 正如你所看到的：\n在 C# 中处理非泛型 Task，在 F# 中意味着使用 unit 作为 Async 的泛型参数：Async\u0026lt;unit\u0026gt;。不要使用 let! x = ...，你只需要 do!。 Task.WhenAll 的等价物是 Async.Parallel。 例 12：编写更少符号，提升 F# 脚本的可阅读性！ 相信你已经明白了 F# 中元组和柯里化参数的区别。后者更推荐使用。\n你可能明白，写这么多小括号其实只是为了映射元组中的东西。事实上，这是刚从 C# 转到 F# 的思维惯性。\nF# 的简洁之处：\n没有那么多的括号，因为你不再使用元组了。 不需要使用分号，如果你只使用 EOL 分隔符。 不需要使用大括号（在 F# 中处理记录类型时才需要它们）。 让 F# 编译器推断类型，就不需要多次使用冒号 :。 更多地使用管道运算符 |\u0026gt;，以避免在一大串代码的右边还要写一堆小括号。 在 F# 中的 if 表达式中不需要小括号（与 C# 相反）。 有了这些要点，我们来重写之前的所有 F# 实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 open System let exitCode = if incomingChar = Environment.NewLine then 1 elif not (incomingChar = String.Empty) then 2 elif incomingChar \u0026lt;\u0026gt; \u0026#34;\\t\u0026#34; \u0026amp;\u0026amp; incomingChar.Length \u0026gt; 1 then 3 else 4 Environment.Exit exitCode 1 2 3 4 5 6 7 8 9 10 11 let intArray = [| 1 2 3 |] let intList = [ 4 5 6 ] let sequenceOfIntegers = intList let dic = dict [ (\u0026#34;One\u0026#34;, 1) (\u0026#34;Two\u0026#34;, 2) ] 1 2 3 4 5 6 7 8 9 10 11 12 13 try try TrySomething someParam with | :? SomeException as ex -\u0026gt; if SomeCondition ex then DoSomethingElse ex raise OtherException else reraise() finally MakeSureToCleanup someParam 1 2 use reader = new StreamReader someFile DoStuff reader 1 2 3 4 5 6 7 8 9 10 11 12 let Check someParam1 someParam2 = match someParam1 with | Some someValue -\u0026gt; // like \u0026#39;as\u0026#39; in C#, you cast and want the value let str = someValue.ToString() stringBuilder.Append str |\u0026gt; ignore | None -\u0026gt; () match someParam2 with | Some _ -\u0026gt; // like \u0026#39;is\u0026#39; in C#, you don\u0026#39;t care about the value stringBuilder.Append String.Empty |\u0026gt; ignore | _ -\u0026gt; () 1 2 3 4 5 6 7 8 type Foo = { Bar: int Baz: string } module FooFactory = let internal CreateFoo () = { Bar = 42 Baz = \u0026#34;forty-two\u0026#34; } 1 2 3 4 5 6 7 module Foo = let Baz() = false let rec Bar() = if Baz() then Bar() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 module SomeFsharpModule = let SendingAnonymousMethodAsDelegate1() = let DelegateReception1 dlg = dlg() DelegateReception1(fun _ -\u0026gt; Console.WriteLine \u0026#34;hello 1\u0026#34; ) let SendingAnonymousMethodAsDelegate2() = let DelegateReception2 dlg = let bar = \u0026#34;baz\u0026#34; dlg bar DelegateReception2(fun bar -\u0026gt; Console.WriteLine(\u0026#34;hello 2 \u0026#34; + bar) ) let SendingAnonymousMethodAsDelegate3() = let DelegateReception3 dlg = let result = dlg() () DelegateReception3(fun _ -\u0026gt; Console.WriteLine \u0026#34;hello 3\u0026#34; 3 ) let SendingAnonymousMethodAsDelegate4() = let DelegateReception4 dlg = let bar = 4.0 let result = dlg bar () DelegateReception4(fun bar -\u0026gt; Console.WriteLine(\u0026#34;hello 4 \u0026#34; + bar.ToString()) int64 4 ) 1 2 3 match int.TryParse someString with | true, anInteger -\u0026gt; DoSomethingWithAnInteger anInteger | false, _ -\u0026gt; DoSomethingElse() 1 2 3 4 5 let rec ReceiveNonTuple str i = let counter = i + 1 Console.WriteLine str ReceiveNonTuple str counter true 1 2 3 4 5 6 7 let Multiply x y = x * y let Double x = let doubleFunc = Multiply 2 let result = doubleFunc x result 1 let aStringToShowToTheUser = sprintf \u0026#34;Hello %s, I see you are %i years old\u0026#34; name age 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 type Ingredients () = class end type Toast (i: Ingredients) = class end let ToastBread i: Async\u0026lt;Toast\u0026gt; = async { return Toast i } let GatherIngredients () = async { return Ingredients() } let Make2Toasts i = async { let twoJobs: List\u0026lt;Async\u0026lt;Toast\u0026gt;\u0026gt; = [ToastBread i; ToastBread i] let! _ = Async.Parallel twoJobs return () } let MakeToasts() = async { let! i = GatherIngredients() do! Make2Toasts i } [\u0026lt;EntryPoint\u0026gt;] let main argv = Console.WriteLine \u0026#34;Hello World!\u0026#34; MakeToasts() |\u0026gt; Async.RunSynchronously Console.WriteLine \u0026#34;Bye world!\u0026#34; 0 // return an integer exit code 祝贺你! 你学习了足够的知识，大概可以理解 80% 的 F# 代码了。\n或者说 80% 的简单 F# 代码，也就是大多数 F# 脚本中所使用的。\n我可以向你解释如何在 F# 中建立相当于类（有行为、构造函数、属性）或结构（值类型和堆栈分配）但是：\n这些不是 F# 的惯用写法 大多数脚本甚至不需要类型，它们只需要函数、值和调用（如果你把 F# 当脚本用） 无论如何，我建议下一步：\n观看这个 讲座 看看这篇 文章 如果过了一段时间，你还在为从 C# 转换至 F# 而挣扎，也可以时不时地使用这个 工具。\n","date":"2022-08-26T00:00:00Z","image":"https://kyocius.github.io/p/fsharp-for-csharp-devs/head_hu7ae8c9477ae0a68f34fbf9d5a3829117_280528_120x120_fill_box_smart1_3.png","permalink":"https://kyocius.github.io/p/fsharp-for-csharp-devs/","title":"写给 C# 开发者的 F# 光速入门教程"},{"content":"前言 就是太久没写异步，有的用法忘了。所以写篇博客回顾一下。\n大量参考《C# 10 in a Nutshell》\n线程 Thread 虽然在 C# 中 Task 的使用频率远超直接使用线程，但是有关线程的概念还是要复习一下的。\n才不是因为我全忘了\n创建线程 Create a Thread 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 using System; using System.Threading; var t = new Thread(WriteY); t.Start(); for (var i = 0; i \u0026lt; 1000; i++) { Console.Write(\u0026#34;x\u0026#34;); } void WriteY() { for (var i = 0; i \u0026lt; 1000; i++) Console.Write(\u0026#34;y\u0026#34;); } //输出： xxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyy... xxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyy... xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyy... yyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxx... 我们可以通过 Name 属性来访问线程的名字：\n1 WriteLine(Thread.CurrentThread.Name); Join 与 Sleep 你可以使用 Join 方法来等待线程结束：\n1 2 3 4 5 6 Thread t = new Thread(Go); t.Start(); t.Join(); Console.WriteLine(\u0026#34;线程t结束\u0026#34;); void Go() { for (var i = 0; i \u0026lt; 1000; i++) Console.Write(\u0026#34;y\u0026#34;); } 这段代码会打印 y 1000 次然后才会输出 线程t结束。\n下面是 Sleep 的用法：\n1 2 Thread.Sleep(TimeSpan.FromHours(1)); //睡一小时 Thread.Sleep(500) //睡500毫秒 特殊的是：\nThread.Sleep(0) 可以放弃当前线程，主动将 CPU 移交给其它线程。\nThread.Yield() 方法作用类似，只是移交相同的处理器。\n阻塞线程 Blocking 查询阻塞状态：\n1 bool isBlocked = (someThread.ThreadState \u0026amp; ThreadState.WaitSleepJoin) != 0; ThreadState 是一个 flags 枚举。\nI/O 密集型 \u0026amp; 计算密集型 Bound 两者是 C# 并发中非常重要的概念。\n等待事件发生的操作叫作 I/O 密集型（I/O-bound） 占用 CPU 来处理数据叫计算密集型（Compute-bound） 局部变量 \u0026amp; 共享状态 Local \u0026amp; Shared State CLR 会分配给每个线程不同的内存栈，所以某一线程的局部变量是与其它线程隔绝的：\n1 2 3 4 5 6 7 new Thread (Go).Start(); // 在新线程调用Go方法 Go(); // 在主线程调用Go方法 void Go() { //局部变量cycles for (int cycles = 0; cycles \u0026lt; 5; cycles++) Console.Write (\u0026#39;?\u0026#39;); } 结果可想而知，会输出 10 个问号「?」。\n但是线程可以共享数据：如果它们有对同一对象或变量的引用：\n1 2 3 4 5 6 7 8 9 bool _done = false; new Thread (Go).Start(); Go() ; void Go() { if (!_done) { _done = true; Console.WriteLine (\u0026#34;Done\u0026#34;); } } 两个线程共享了 _done 所以「Done」仅仅输出一次。\n换成 Lambda 表达式也是可以共享的：\n1 2 3 4 5 6 7 bool done = false; ThreadStart action = () =\u0026gt; { if (!done) { done = true; Console.WriteLine (\u0026#34;Done\u0026#34;); } }; new Thread (action).Start(); action(); 这引出了一个关键概念：线程安全！\n线程锁 \u0026amp; 线程安全 Lock \u0026amp; Thread Safety 来看看锁🔒：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class ThreadSafe { static bool _done; static readonly object _locker = new object(); static void Main() { new Thread (Go).Start(); Go(); } static void Go() { lock (_locker) { if (!_done) { Console.WriteLine (\u0026#34;Done\u0026#34;); _done = true; } } } } 其实这也不必多说，就是阻止两个线程同时修改某一变量罢了。\n向线程传递数据 有的时候，我们想在线程开始的时候传递数据，可以这么做：\n1 2 3 4 Thread t = new Thread ( () =\u0026gt; Print (\u0026#34;Hello from t!\u0026#34;) ); t.Start(); void Print (string message) =\u0026gt; Console.WriteLine (message); 用 Lambda 表达式也行：\n1 2 3 4 5 new Thread (() =\u0026gt; { Console.WriteLine (\u0026#34;看！我跑在另一个线程里！\u0026#34;); Console.WriteLine (\u0026#34;有手就行！\u0026#34;); }).Start(); 捕获变量 Captured Variables 一定要小心捕获变量：\n1 2 for (int i = 0; i \u0026lt; 10; i++) new Thread (() =\u0026gt; Console.Write (i)).Start(); 输出结果是不确定的！结果：\n1 0223557799 问题所在是变量 i 指向了循环中同一内存位置。所以变量 i 的值其实一直在被不同线程修改。\n解决方案是使用临时变量：\n1 2 3 4 5 for (int i = 0; i \u0026lt; 10; i++) { int temp = i; new Thread (() =\u0026gt; Console.Write (temp)).Start(); } 再来看看类似的问题：\n1 2 3 4 5 6 7 string text = \u0026#34;t1\u0026#34;; Thread t1 = new Thread ( () =\u0026gt; Console.WriteLine (text) ); text = \u0026#34;t2\u0026#34;; Thread t2 = new Thread ( () =\u0026gt; Console.WriteLine (text) ); t1.Start(); t2.Start(); 因为两个 Lambda 表达式捕获了同一变量 text，所以值 t2 会被输出两次。\n异常处理 先看看不正确的写法：\n1 2 3 4 5 6 7 8 9 10 11 try { new Thread (Go).Start(); } catch (Exception ex) { // 永远不会到达这里！ Console.WriteLine (\u0026#34;Exception!\u0026#34;); } void Go() { throw null; } // 本应该抛出Null引用错误 每个线程有独立的执行路径，所以我们在线程之外捕获异常是没用的。\n解决方案是把异常处理语句放入方法内：\n1 2 3 4 5 6 7 8 9 10 11 12 13 new Thread (Go).Start(); void Go() { try { throw null; } catch (Exception ex) { // 这样就可以捕获了 } } 集中异常处理 Centralized Exception Handler 在 WPF、UWP 或者 WinForm 应用里，我们可以订阅全局异常处理事件 Application.DispatcherUnhandledException 以及 Application.ThreadException。\n前台线程 \u0026amp; 后台线程 Foreground \u0026amp; Background Threads 默认情况下，你显式创建的线程都是前台线程。程序结束，你的显式线程也会结束。\n后台线程则不然，依然会保持运行。\n你可以用 IsBackground 属性来操作前后台状态：\n1 2 3 4 5 6 static void Main (string[] args) { Thread worker = new Thread ( () =\u0026gt; Console.ReadLine() ); if (args.Length \u0026gt; 0) worker.IsBackground = true; worker.Start(); } 线程级别 Thread Priority 一个线程的 Priority 属性决定了它可以运行多久（相较于其它线程而言）：\n1 enum ThreadPriority { Lowest, BelowNormal, Normal, AboveNormal, Highest } 发信号 Signaling 有时，你需要线程一直等待直到收到其它线程发送的通知，这就是 Signaling。\n最简单的 Signaling 结构是 ManualResetEvent 。\n在一个 ManualResetEvent 块中调用 WaitOne 方法，阻塞当前线程直到另一线程调用 Set 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var signal = new ManualResetEvent (false); new Thread (() =\u0026gt; { Console.WriteLine (\u0026#34;Waiting for signal...\u0026#34;); signal.WaitOne(); signal.Dispose(); Console.WriteLine (\u0026#34;Got signal!\u0026#34;); }).Start(); Thread.Sleep(2000); signal.Set(); // 发送信号 线程在客户端应用 Threading in Rich Client Applications 在 WPF 或者 UWP 等等客户端的开发中，但我们要执行耗时的任务时，通常的做法是启动一个「Worker」线程。\n当你想要从「Worker」线程更新 UI 时，你必须传递至 UI 线程。编程术语「编列 Marshal」专门指代这一行为。\nWPF：调用 Dispatcher 对象的 BeginInvoke 或 Invoke 方法\nUWP：调用 Dispatcher 对象的 RunAsync 或 Invoke 方法\nWinForm：调用控件的 BeginInvoke 或 Invoke 方法\n这些方法的实质都是把你想要执行的方法推送到 UI 线程的消息队列中。\n但是 Invoke 方法有一点特殊：它会阻塞线程直到消息被 UI 线程处理。因此它可以用来返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 partial class MyWindow : Window { public MyWindow() { InitializeComponent(); new Thread (Work).Start(); } void Work() { Thread.Sleep (5000); // 假装耗时任务 UpdateMessage (\u0026#34;The answer\u0026#34;); } void UpdateMessage (string message) { Action action = () =\u0026gt; txtMessage.Text = message; Dispatcher.BeginInvoke (action); } } 同步上下文 Synchronization Contexts WPF、UWP 等等框架都实现了这个类（子类）。\n这个类被放在 System.ComponentModel 中，用来帮助我们进行 「Marshal」操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 partial class MyWindow : Window { SynchronizationContext _uiSyncContext; public MyWindow() { InitializeComponent(); // 获取当前UI线程的同步上下文 _uiSyncContext = SynchronizationContext.Current; new Thread (Work).Start(); } void Work() { Thread.Sleep (5000); // 假装耗时操作 UpdateMessage (\u0026#34;The answer\u0026#34;); } void UpdateMessage (string message) { // Marshal委托至UI线程 _uiSyncContext.Post (_ =\u0026gt; txtMessage.Text = message, null); } } 调用 Post 方法等价于调用 BeginInvoke 方法。\n线程池 The Thread Pool 线程池就是用来方便多线程管理的。\n有几点值得注意：\n你不能为池线程设置 Name 属性，这会让 Debug 更加困难\n池线程通常是后台线程\n阻塞池线程会导致性能降低\n你可以改变池线程的级别。\n你可以通过 Thread.CurrentThread.IsThreadPoolThread. 来指定是否让线程在池里运行。\n进入线程池 Enter the pool 最简单的方式是：\n1 Task.Run (() =\u0026gt; Console.WriteLine (\u0026#34;你先别急，Task后面会讲\u0026#34;)); 在 .NET Framework 4.0 以前的上古时期 C# 没有 Task 协程，是这样进入线程池的：\n1 ThreadPool.QueueUserWorkItem (notUsed =\u0026gt; Console.WriteLine (\u0026#34;Hello\u0026#34;)); 隐式使用线程池的库：\nASP.NET Core / Web API 应用\nSystem.Timers.Timer 和 System.Threading.Timer\nBackgroundWorker 类（传统）\n线程池卫生 Hygiene in the thread pool 线程池还有一个作用是保证 CPU 不会「超额认购 Oversubscription」。\n「Oversubscription」指的是活跃线程数量超过 CPU 核心数量的状态。\n总之，CLR 会通过排序任务队列和减速任务启动来阻止「超额认购」。\n任务 Task 创建任务 Create a Task 1 2 Task.Run (() =\u0026gt; Console.WriteLine (\u0026#34;Foo\u0026#34;)); Console.ReadLine(); //用来阻塞一下 等待 Wait 和线程的 Join 类似：\n1 2 3 4 5 6 7 8 Task task = Task.Run (() =\u0026gt; { Thread.Sleep (2000); Console.WriteLine (\u0026#34;Foo\u0026#34;); }); Console.WriteLine (task.IsCompleted); // False task.Wait(); // 阻塞直到Task结束 耗时任务 LongRunning Task CLR 默认会让 Task 运行在池线程（适用于短时计算的线程）。\n为了运行耗时长的 Task：\n1 Task task = Task.Factory.StartNew (() =\u0026gt; ..., TaskCreationOptions.LongRunning); 返回值 Return Values 最简单的返回值写法：\n1 Task\u0026lt;int\u0026gt; task = Task.Run (() =\u0026gt; { Console.WriteLine (\u0026#34;Foo\u0026#34;); return 3; }); 你可以通过 Task 的 Result 属性来获取返回值。这步操作将会阻塞线程直至 Task 结束：\n1 2 int result = task.Result; Console.WriteLine(result); 接下来，我们创建一个使用 LINQ 的 Task，用以计算 300 0000 以内的素数：\n1 2 3 4 5 6 Task\u0026lt;int\u0026gt; primeNumberTask = Task.Run (() =\u0026gt; Enumerable.Range (2, 3000000).Count (n =\u0026gt; Enumerable.Range (2, (int)Math.Sqrt(n)-1).All (i =\u0026gt; n % i \u0026gt; 0))); Console.WriteLine (\u0026#34;Task running...\u0026#34;); Console.WriteLine (\u0026#34;The answer is \u0026#34; + primeNumberTask.Result); 异常 Exception 1 2 3 4 5 6 7 8 9 10 11 12 13 //开启一个抛出NullReferenceException的Task Task task = Task.Run (() =\u0026gt; { throw null; }); try { task.Wait(); } catch (AggregateException aex) { if (aex.InnerException is NullReferenceException) Console.WriteLine (\u0026#34;Null!\u0026#34;); else throw; } 后续 Continuations 顾名思义，就是当 Task 结束之后该干啥：\n1 2 3 4 5 6 7 8 9 10 Task\u0026lt;int\u0026gt; primeNumberTask = Task.Run (() =\u0026gt; Enumerable.Range (2, 3000000).Count (n =\u0026gt; Enumerable.Range (2, (int)Math.Sqrt(n)-1).All (i =\u0026gt; n % i \u0026gt; 0))); var awaiter = primeNumberTask.GetAwaiter(); awaiter.OnCompleted (() =\u0026gt; { int result = awaiter.GetResult(); Console.WriteLine (result); }); C# 异步编程 终于到了本章的重头戏了！\nAwaiting await 关键字自动附加后续操作。\n简单使用：\n1 2 var result = await expression; statement(s); 编译器会把这小段代码自动转化为：\n1 2 3 4 5 6 var awaiter = expression.GetAwaiter(); awaiter.OnCompleted (() =\u0026gt; { var result = awaiter.GetResult(); statement(s); }); 来看看之前的代码：\n1 2 3 4 5 6 Task\u0026lt;int\u0026gt; GetPrimesCountAsync (int start, int count) { return Task.Run (() =\u0026gt; ParallelEnumerable.Range (start, count).Count (n =\u0026gt; Enumerable.Range (2, (int)Math.Sqrt(n)-1).All (i =\u0026gt; n % i \u0026gt; 0))); } 使用 await 关键字，我们可以如下调用：\n1 2 int result = await GetPrimesCountAsync (2, 1000000); Console.WriteLine (result); 但在编译前，我们需要给外层代码加一个 async 关键字：\n1 2 3 4 5 async void DisplayPrimesCount() { int result = await GetPrimesCountAsync (2, 1000000); Console.WriteLine (result); } async 关键字只能加给返回值类型是 void，Task 以及 Task\u0026lt;TResult\u0026gt; 的方法。\n当返回值是空时：\n1 2 await Task.Delay (5000); Console.WriteLine (\u0026#34;Five seconds passed!\u0026#34;); 捕获局部变量 Capturing local state await 的真正力量在于它可以出现在代码的任意位置（但不能在线程锁以及 unsafe 块中）：\n1 2 3 4 5 async void DisplayPrimeCounts() { for (int i = 0; i \u0026lt; 10; i++) Console.WriteLine (await GetPrimesCountAsync (i*1000000+2, 1000000)); } 在第一次执行 GetPrimesCountAsync 之后，变量 i 的值会被保存。\n在 UI 中等待 Awaiting in a UI 我们先从一个同步的代码开始：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class TestUI : Window { Button _button = new Button { Content = \u0026#34;Go\u0026#34; }; TextBlock _results = new TextBlock(); public TestUI() { var panel = new StackPanel(); panel.Children.Add (_button); panel.Children.Add (_results); Content = panel; _button.Click += (sender, args) =\u0026gt; Go(); } void Go() { for (int i = 1; i \u0026lt; 5; i++) _results.Text += GetPrimesCount (i * 1000000, 1000000) + \u0026#34; primes between \u0026#34; + (i*1000000) + \u0026#34; and \u0026#34; + ((i+1)*1000000-1) + Environment.NewLine; } int GetPrimesCount (int start, int count) { return ParallelEnumerable.Range (start, count).Count (n =\u0026gt; Enumerable.Range (2, (int) Math.Sqrt(n)-1).All (i =\u0026gt; n % i \u0026gt; 0)); } } 可以看到点击按钮就会阻塞线程。\n接下来我们使用异步改写。\n第一步是把计算素数的方法改成异步的：\n1 2 3 4 Task\u0026lt;int\u0026gt; GetPrimesCountAsync (int start, int count) { return Task.Run (() =\u0026gt; ParallelEnumerable.Range (start, count).Count(n =\u0026gt; Enumerable.Range(2, (int) Math.Sqrt(n)-1).All (i =\u0026gt; n % i \u0026gt; 0))); } 第二步是修改 Go 方法：\n1 2 3 4 5 6 7 8 async void Go() { _button.IsEnabled = false; for (int i = 1; i \u0026lt; 5; i++) _results.Text += await GetPrimesCountAsync (i * 1000000, 1000000) + \u0026#34; primes between \u0026#34; + (i*1000000) + \u0026#34; and \u0026#34; + ((i+1)*1000000-1) + Environment.NewLine; _button.IsEnabled = true; } 再来另一个例子，这回我们想要从网络上异步地下载数据了。\n重写 Go 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 async void Go() { _button.IsEnabled = false; string[] urls = \u0026#34;yoroion.github.io www.oreilly.com sinoahpx.github.io\u0026#34;.Split(); int totalLength = 0; try { foreach (string url in urls) { var uri = new Uri(\u0026#34;http://\u0026#34; + url) byte[] data = await new WebClient().DownloadDataTaskAsync (uri); _results.Text += \u0026#34;Length of \u0026#34; + url + \u0026#34; is \u0026#34; + data.Length + Environment.NewLine; totalLength += data.Length; } _results.Text += \u0026#34;Total length: \u0026#34; + totalLength; } catch { _results.Text += \u0026#34;Error: \u0026#34; + ex.Message; } finally { _button.IsEnabled = true; } } 我们附加在 UI 控件上的 Event Handler 在消息队列（message loop）中进行。\n当我们的 Go 方法运行时，直至遇到 await 表达式，会跳转回消息队列来来响应其它事件。\n编写异步方法 Writing Asynchronous Functions 编写异步方法，我们可以把空返回值的方法改成返回 Task：\n1 2 3 4 5 6 async Task PrintAnswerToLife() //Task 替代了 void { await Task.Delay (5000); int answer = 21 * 2; Console.WriteLine (answer); } 可以发现我们并没有显式地返回 Task，编译器帮我们简化了：\n1 2 3 4 5 async Task Go() { await PrintAnswerToLife(); Console.WriteLine(\u0026#34;Done\u0026#34;); } 返回 Task 1 2 3 4 5 6 async Task\u0026lt;int\u0026gt; GetAnswerToLife() { await Task.Delay (5000); int answer = 21 * 2; return answer; //直接返回整型 } 整体看一下代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 async Task Go() { await PrintAnswerToLife(); Console.WriteLine (\u0026#34;Done\u0026#34;); } async Task PrintAnswerToLife() { int answer = await GetAnswerToLife(); Console.WriteLine (answer); } async Task\u0026lt;int\u0026gt; GetAnswerToLife() { await Task.Delay (5000); int answer = 21 * 2; return answer; } 这也揭示了 C# 中编写异步方法的基本原则:\n先同步地编写代码 将同步方法改成异步的 返回值改成 Task 或 Task 并行 Parallelism ","date":"2022-08-15T00:00:00Z","image":"https://kyocius.github.io/p/advanced-csharp-1/head_hu6445997bcd53608f7e2f035aad872a86_31881_120x120_fill_box_smart1_3.png","permalink":"https://kyocius.github.io/p/advanced-csharp-1/","title":"鎧恩的 C# 进阶小册  01 - 并发与异步"},{"content":"前言 之前我们见识了 Rx.NET 的基本用法，把 .NET 事件转化成了可观察数据流，并且补充了一些拓展知识（Ex），现在我们要接着深入 Rx.NET 的核心技术了。\n普通数据流 还记得吗，IObservable 接口只有一个方法 Subscribe，是 Rx.NET 的基础。\n我们将试着打造一个即时通讯系统。\n实现 IObservable 接口 在实际的开发中，非常不推荐直接实现 IObservable 接口，但是理解这个流程对我们的学习很有帮助。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 using System; using System.Reactive.Disposables; public class NumbersObservable : IObservable\u0026lt;int\u0026gt; { private readonly int _amount; public NumbersObservable(int amount) { _amount = amount; } public IDisposable Subscribe(IObserver\u0026lt;int\u0026gt; observer) { for (int i = 0; i \u0026lt; _amount; i++) { observer.OnNext(i); } observer.OnCompleted(); return Disposable.Empty; } } 实现 Observer 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class ConsoleObserver\u0026lt;T\u0026gt; : IObserver\u0026lt;T\u0026gt; { private readonly string _name; public ConsoleObserver(string name=\u0026#34;\u0026#34;) { _name = name; } public void OnNext(T value) { Console.WriteLine(\u0026#34;{0} - OnNext({1})\u0026#34;,_name,value); } public void OnError(Exception error) { Console.WriteLine(\u0026#34;{0} - OnError:\u0026#34;, _name); Console.WriteLine(\u0026#34;\\t {0}\u0026#34;, error); } public void OnCompleted() { Console.WriteLine(\u0026#34;{0} - OnCompleted()\u0026#34;, _name); } } 最后消费它：\n1 2 3 var numbers = new NumbersObservable(5); var subscription = numbers.Subscribe(new ConsoleObserver\u0026lt;int\u0026gt;(\u0026#34;numbers\u0026#34;)); 看看结果：\n1 2 3 4 5 6 numbers - OnNext(0) numbers - OnNext(1) numbers - OnNext(2) numbers - OnNext(3) numbers - OnNext(4) numbers - OnCompleted() 我们现在手动实现了一个可观察数据流和观察者。\n再来个扩展方法方便我们打印，\n注意！这个方法将会贯穿之后的章节：\n1 2 3 4 5 6 7 public static class Extensions { public static IDisposable SubscribeConsole\u0026lt;T\u0026gt;( this IObservable\u0026lt;T\u0026gt; observable, string name = \u0026#34;\u0026#34;) { return observable.Subscribe(new ConsoleObserver\u0026lt;T\u0026gt;(name)); } } 手动创建 Observable 的缺陷 手动创建可观察数据流一般不推荐且很少用，因为如此明显繁琐且容易出错。\n除此之外，如果你不小心在 OnComplete 方法之后调用了 OnNext：\n1 2 3 4 5 6 7 8 9 10 11 public IDisposable Subscribe(IObserver\u0026lt;int\u0026gt; observer) { for (int i = 0; i \u0026lt; _amount; i++) { observer.OnNext(i); } observer.OnCompleted(); observer.OnNext(_amount); // 注意这行 return Disposable.Empty; } 你将得到以下结果：\n1 2 3 4 5 6 7 errorTest - OnNext(0) errorTest - OnNext(1) errorTest - OnNext(2) errorTest - OnNext(3) errorTest - OnNext(4) errorTest - OnComplete errorTest - OnNext(5) 怎么会事捏， OnComplete 之后居然还能订阅到数据？\n这是 Rx 背后 Observable 与 Observer 的 Repeat 方法重新订阅导致的。\nObservableBase 接口 手写也不是不可以，比如当你想封装一个复杂的、包含事件属性的接口的时候：\n1 2 3 4 5 6 7 public interface IChatConnection { event Action\u0026lt;string\u0026gt; Received; event Action Closed; event Action\u0026lt;Exception\u0026gt; Error; void Disconnect(); } 我们一般会写个 Client：\n1 2 3 4 5 6 7 8 public class ChatClient { ... public IChatConnection Connect(string user, string password) { // 连接服务 } } 再手动改写成一个 Observable：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 using System; using System.Reactive; using System.Reactive.Disposables; public class ObservableConnection : ObservableBase\u0026lt;string\u0026gt; { private readonly IChatConnection _chatConnection; public ObservableConnection(IChatConnection chatConnection) { _chatConnection = chatConnection; } protected override IDisposable SubscribeCore(IObserver\u0026lt;string\u0026gt; observer) { Action\u0026lt;string\u0026gt; received = message =\u0026gt; { observer.OnNext(message); }; Action closed = () =\u0026gt; { observer.OnCompleted(); }; Action\u0026lt;Exception\u0026gt; error = ex =\u0026gt; { observer.OnError(ex); }; _chatConnection.Received += received; _chatConnection.Closed += closed; _chatConnection.Error += error; return Disposable.Create(() =\u0026gt; { _chatConnection.Received -= received; _chatConnection.Closed -= closed; _chatConnection.Error -= error; _chatConnection.Disconnect(); }); } } 发现没，这其实就是 SignalR 的写法（微软的后端框架）\n现在消费：\n1 2 3 4 5 6 var chatClient = new ChatClient(); var connection = chatClient.Connect(\u0026#34;guest\u0026#34;, \u0026#34;guest\u0026#34;); IObservable\u0026lt;string\u0026gt; observableConnection = new ObservableConnection(connection); // 最开始的那个类 var subscription = observableConnection.SubscribeConsole(\u0026#34;receiver\u0026#34;); 写个扩展方法来简化操作：\n1 2 3 4 5 6 7 public static class ChatExtensions { public static IObservable\u0026lt;string\u0026gt; ToObservable(this IChatConnection connection) { return new ObservableConnection(connection); } } 综合下来看，这么手动写也太踏马折磨了。Rx 有没有方法来简化这些操作呢？\nObservable.Create 方法 别傻乎乎地手写了，Rx 可是提供了好用的工厂函数呢。\n1 2 3 4 5 6 7 8 9 Observable.Create\u0026lt;int\u0026gt;(observer =\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { observer.OnNext(i); } observer.OnCompleted(); return Disposable.Empty; }); 直接写个 Lambda 表达式来作为 Subscribe 方法。\nObservable.Create 非常灵活，因此也被大量使用在 Rx 的应用中。\n延迟初始化 Defer 1 2 3 4 5 public IObservable\u0026lt;string\u0026gt; ObserveMessages(string user, string password) { var connection = Connect(user, password); return connection.ToObservable(); } 当我们想要这个可观察数据流仅在有观察者订阅它的时候才会被创建时，我们可以使用 Observable.Defer 方法来延迟初始化：\n1 2 3 4 5 6 7 8 public IObservable\u0026lt;string\u0026gt; ObserveMessagesDeferred(string user, string password) { return Observable.Defer(() =\u0026gt; { var connection = Connect(user, password); return connection.ToObservable(); }); } 需要指出的是，由这些工厂函数创建的可观察数据流并不能共享观察者：\n1 2 3 var messages = chatClient.ObserveMessagesDeferred(\u0026#34;user\u0026#34;,\u0026#34;password\u0026#34;); var subscription1 = messages.SubscribeConsole(); var subscription2 = messages.SubscribeConsole(); 也就是说， subscription1 和 subscription2 是两个完全独立的实例。\n关于「共享流」「热流」以及「冷流」的知识将会在第六章讲解。\n由事件转换 在第二章我们已经见识过了，这回来点儿更深入的。\n先看定义：\n1 FromEventPattern\u0026lt;TDelegate, TEventArgs\u0026gt;(Action\u0026lt;TDelegate\u0026gt; addHandler, Action\u0026lt;TDelegate\u0026gt; removeHandler) 标准事件 来个事件：\n1 public event RoutedEventHandler Click; 这个委托类型是 System.Windows 中定义好的：\n1 public delegate void RoutedEventHandler(object sender, System.Windows.RoutedEventArgs e) 转化成可观察的事件流：\n1 2 3 4 5 IObservable\u0026lt;EventPattern\u0026lt;RoutedEventArgs\u0026gt;\u0026gt; clicks = Observable.FromEventPattern\u0026lt;RoutedEventHandler, RoutedEventArgs\u0026gt;( h =\u0026gt; theButton.Click += h, h =\u0026gt; theButton.Click -= h); clicks.SubscribeConsole(); Rx 还提供了一种简化的写法，但并不推荐：\n1 2 IObservable\u0026lt;EventPattern\u0026lt;object\u0026gt;\u0026gt; clicks = Observable.FromEventPattern(theButton, \u0026#34;Click\u0026#34;); 不标准事件 并不是所有事件的参数都是一个 Sender + 一个 EventArgs。\n1 2 3 4 5 6 7 public delegate void NetworkFoundEventHandler(string ssid); class WifiScanner { public event NetworkFoundEventHandler NetworkFound = delegate { }; // ... } 可以看到这个事件需要一个字符串类型的参数。\n之前的 FromEventPattern 就不能用了，Rx 提供了 FromEvent：\n1 IObservable\u0026lt;TEventArgs\u0026gt; FromEvent\u0026lt;TDelegate, TEventArgs\u0026gt;(Action\u0026lt;TDelegate\u0026gt; addHandler, Action\u0026lt;TDelegate\u0026gt; removeHandler); 如此就可以：\n1 2 3 4 5 var wifiScanner = new WifiScanner(); IObservable\u0026lt;string\u0026gt; networks = Observable.FromEvent\u0026lt;NetworkFoundEventHandler, string\u0026gt;( h =\u0026gt; wifiScanner.NetworkFound += h, h =\u0026gt; wifiScanner.NetworkFound -= h); 更复杂的事件 Of course，还有更复杂的事件：\n1 2 3 4 5 6 public delegate void ExtendedNetworkFoundEventHandler(string ssid, int strength); class WifiScanner { public event ExtendedNetworkFoundEventHandler ExtendedNetworkFound = delegate { }; } 放心，FromEvent 提供了重载：\n1 2 3 4 IObservable\u0026lt;TEventArgs\u0026gt; FromEvent\u0026lt;TDelegate, TEventArgs\u0026gt;( Func\u0026lt;Action\u0026lt;TEventArgs\u0026gt;, TDelegate\u0026gt; conversion, Action\u0026lt;TDelegate\u0026gt; addHandler, Action\u0026lt;TDelegate\u0026gt; removeHandler); 下面需要利用元组（Tuple）的特性：\n1 2 3 4 5 IObservable\u0026lt;Tuple\u0026lt;string, int\u0026gt;\u0026gt; networks = Observable.FromEvent\u0026lt;ExtendedNetworkFoundEventHandler, Tuple\u0026lt;string, int\u0026gt;\u0026gt;( rxHandler =\u0026gt; (ssid, strength) =\u0026gt; rxHandler(Tuple.Create(ssid, strength)), h =\u0026gt; wifiScanner.ExtendedNetworkFound += h, h =\u0026gt; wifiScanner.ExtendedNetworkFound -= h); 无参事件 1 event Action Connected = delegate { }; 我们需要这么写：\n1 2 3 4 5 IObservable\u0026lt;Unit\u0026gt; connected = Observable.FromEvent(h =\u0026gt; wifiScanner.Connected += h, h =\u0026gt; wifiScanner.Connected -= h); connected.SubscribeConsole(\u0026#34;connected\u0026#34;); Unit 类型代表了「空」，它 ToString 之后的值为「()」\n所以你会得到以下结果：\n1 2 connected - OnNext(()) connected - OnNext(()) 由迭代类型转换 迭代类型和可观察类型长得很像，Rx 也提供了转换的方法。\n迭代类型 → 可观察流 1 2 3 4 IEnumerable\u0026lt;string\u0026gt; names = new []{\u0026#34;AHpx\u0026#34;, \u0026#34;Yoroion\u0026#34;, \u0026#34;Weeknic\u0026#34;, \u0026#34;GodLeaveMe\u0026#34;}; IObservable\u0026lt;string\u0026gt; observable = names.ToObservable(); observable.SubscribeConsole(\u0026#34;names\u0026#34;); 你将会得到：\n1 2 3 4 5 names - OnNext(AHpx) names - OnNext(Yoroion) names - OnNext(Weekenic) names - OnNext(GodLeaveMe) names - OnCompleted() 如果迭代的过程中发生了错误，那么报错就会传递至 OnError 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Program { static void Main(string[] args) { NumbersAndThrow() .ToObservable() .SubscribeConsole(\u0026#34;names\u0026#34;); Console.ReadLine(); } static IEnumerable\u0026lt;int\u0026gt; NumbersAndThrow() { yield return 1; yield return 2; yield return 3; throw new ApplicationException(\u0026#34;报错啦\u0026#34;); yield return 4; } } 输出：\n1 2 3 4 5 enumerable with exception - OnNext(1) enumerable with exception - OnNext(2) enumerable with exception - OnNext(3) enumerable with exception - OnError: System.ApplicationException: Something Bad Happened Rx 还提供了一个更简单的方法，直接订阅迭代类型：\n1 2 IEnumerable\u0026lt;string\u0026gt; names = new[] { \u0026#34;AHpx\u0026#34;, \u0026#34;Yoroion\u0026#34;, \u0026#34;Weeknic\u0026#34;, \u0026#34;GodLeaveMe\u0026#34; }; names.Subscribe(new ConsoleObserver\u0026lt;string\u0026gt;(\u0026#34;subscribe\u0026#34;)); 那么如何合并可观察数据流与迭代类型呢？\n1 2 3 4 5 6 7 ChatClient client = new ChatClient(); IObservable\u0026lt;string\u0026gt; liveMessages = client.ObserveMessages(\u0026#34;user\u0026#34;,\u0026#34;pass\u0026#34;); IEnumerable\u0026lt;string\u0026gt; loadedMessages = LoadMessagesFromDB(); // 假设从数据库加载数据 loadedMessages.ToObservable() .Concat(liveMessages) .SubscribeConsole(\u0026#34;merged\u0026#34;); 注意看，以上代码使用了 Concat 合并了两个流。在所有 Database 数据（Loaded Messages）被加载后，实时数据（Live Messages）才会被发给观察者。\n1 2 3 4 merged - OnNext(loaded1) merged - OnNext(loaded2) merged - OnNext(live message1) merged - OnNext(live message2) 你也可以用以下写法免于手动转换：\n1 2 3 liveMessages .StartWith(loadedMessages) .SubscribeConsole(\u0026#34;loaded first\u0026#34;); 可观察流 → 迭代类型 为啥要把可观察流转化成迭代类型呢？因为有的方法只接受迭代类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var observable = Observable.Create\u0026lt;string\u0026gt;(o =\u0026gt; { o.OnNext(\u0026#34;Observable\u0026#34;); o.OnNext(\u0026#34;To\u0026#34;); o.OnNext(\u0026#34;Enumerable\u0026#34;); o.OnCompleted(); // 当所有OnNext中的值被消费后，线程会进入等待状态 return Disposable.Empty; }); var enumerable = observable.ToEnumerable(); // 可观察流完成时，循环便会结束 foreach (var item in enumerable) { Console.WriteLine(item); } 把可观察流转换成 List：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var observable = Observable.Create\u0026lt;string\u0026gt;(o =\u0026gt; { o.OnNext(\u0026#34;Observable\u0026#34;); o.OnNext(\u0026#34;To\u0026#34;); o.OnNext(\u0026#34;List\u0026#34;); o.OnCompleted(); // 只有当Complete之后，List才会被发送给观察者 return Disposable.Empty; }); IObservable\u0026lt;IList\u0026lt;string\u0026gt;\u0026gt; listObservable = observable.ToList(); listObservable .Select(lst =\u0026gt; string.Join(\u0026#34;,\u0026#34;, lst)) // 使用逗号分隔 .SubscribeConsole(\u0026#34;list ready\u0026#34;); 输出：\n1 2 list ready - OnNext(Observable,To,List) list ready - OnCompleted() 可观察流 → 字典 Rx 提供了如下方法：\n1 IObservable\u0026lt;IDictionary\u0026lt;TKey, TSource\u0026gt;\u0026gt; ToDictionary\u0026lt;TSource, TKey\u0026gt;(this IObservable\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, TKey\u0026gt; keySelector) 简单使用：\n1 2 3 4 5 6 7 8 9 IEnumerable\u0026lt;string\u0026gt; cities = new[] { \u0026#34;London\u0026#34;, \u0026#34;Tel-Aviv\u0026#34;, \u0026#34;Tokyo\u0026#34;, \u0026#34;Rome\u0026#34; }; var dictionaryObservable = cities .ToObservable() .ToDictionary(c =\u0026gt; c.Length); dictionaryObservable .Select(d =\u0026gt; string.Join(\u0026#34;,\u0026#34;, d)) .SubscribeConsole(\u0026#34;dictionary\u0026#34;); 输出：\n1 2 dictionary - OnNext([6, London],[8, Tel-Aviv],[5, Tokyo],[4, Rome]) dictionary - OnCompleted() 但是当两个 Key 的值相同时，它就会报错。\n如果你需要一 Key 对应多值，你就需要 Lookup 类型：\n1 IObservable\u0026lt;ILookup\u0026lt;TKey, TSource\u0026gt;\u0026gt; ToLookup\u0026lt;TSource, TKey\u0026gt;(this IObservable\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, TKey\u0026gt; keySelector) 长得和 ToDictionary 非常相似。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 IEnumerable\u0026lt;string\u0026gt; cities = new[] { \u0026#34;London\u0026#34;, \u0026#34;Tel-Aviv\u0026#34;, \u0026#34;Tokyo\u0026#34;, \u0026#34;Rome\u0026#34;, \u0026#34;Madrid\u0026#34; }; var lookupObservable = cities .ToObservable() .ToLookup(c =\u0026gt; c.Length); lookupObservable .Select(lookup =\u0026gt; { var groups = new StringBuilder(); foreach (var grp in lookup) groups.AppendFormat(\u0026#34;[Key:{0} =\u0026gt; {1}]\u0026#34;,grp.Key,grp.Count()); return groups.ToString(); }) .SubscribeConsole(\u0026#34;lookup\u0026#34;); 输出：\n1 2 lookup - OnNext([Key:6 =\u0026gt; 2][Key:8 =\u0026gt; 1][Key:5 =\u0026gt; 1][Key:4 =\u0026gt; 1]) lookup - OnCompleted() 因为伦敦（London）和马德里（Madrid）的长度都是 6，Lookup Key 6 就有两个值。\nRx 创建型操作符 可观察循环 使用 Observable.Generate 来创建类似迭代的数据流：\n1 2 3 4 5 IObservable\u0026lt;TResult\u0026gt; Generate\u0026lt;TState, TResult\u0026gt;( TState initialState, Func\u0026lt;TState, bool\u0026gt; condition, Func\u0026lt;TState, TState\u0026gt; iterate, Func\u0026lt;TState, TResult\u0026gt; resultSelector) 简单使用：\n1 2 3 4 5 6 7 IObservable\u0026lt;int\u0026gt; observable = Observable.Generate( 0, //初始值 i =\u0026gt; i \u0026lt; 10, //条件 i =\u0026gt; i + 1, //迭代 i =\u0026gt; i*2); //数据处理 observable.SubscribeConsole(); 你会得到：0, 2, 4, 6, 8, 10, 12, 14, 16, 18。\n使用 Observable.Range 简化以上操作：\n1 IObservable\u0026lt;int\u0026gt; Range(int start, int count) 顾名思义：\n1 2 3 4 IObservable\u0026lt;int\u0026gt; observable = Observable .Range(0, 10) .Select(i =\u0026gt; i*2); 读取文件 我们利用 Generate 方法来读取文件：\n1 2 3 4 5 6 7 8 IObservable\u0026lt;string\u0026gt; lines = Observable.Generate( File.OpenText(\u0026#34;TextFile.txt\u0026#34;), //这个地方有瑕疵 s =\u0026gt; !s.EndOfStream, //迭代到文件末端 s =\u0026gt; s, //状态就是文件流本身 s =\u0026gt; s.ReadLine()); lines.SubscribeConsole(\u0026#34;lines\u0026#34;); 输出：\n1 2 3 4 5 lines - OnNext(The 1st line) lines - OnNext(The 2nd line) lines - OnNext(The 3rd line) lines - OnNext(The 4th line) lines - OnCompleted() 但是捏，我们肯定知道 IO 流的资源没有及时释放。文件还保持在打开的状态。\n在平时写 C# 中，我们一般会使用 using var ... 来自动释放资源。\n在 Rx.NET 中，提供了 Observable.Using：\n1 2 3 4 5 6 7 8 9 10 11 IObservable\u0026lt;string\u0026gt; lines = Observable.Using( () =\u0026gt; File.OpenText(\u0026#34;TextFile.txt\u0026#34;), stream =\u0026gt; Observable.Generate( stream, //初始状态就是它自己 s =\u0026gt; !s.EndOfStream, s =\u0026gt; s, s =\u0026gt; s.ReadLine()) ); lines.SubscribeConsole(\u0026#34;lines\u0026#34;); 原始可观察流 有些 Rx 创建型操作符没啥用，但是可以拿来玩玩或者测试。\nReturn 1 2 Observable.Return(\u0026#34;Hello World\u0026#34;) .SubscribeConsole(\u0026#34;Return\u0026#34;); 输出：\n1 2 Return - OnNext(Hello World) Return - OnCompleted() Never 一个永不结束的数据流：\n1 2 Observable.Never\u0026lt;string\u0026gt;() .SubscribeConsole(\u0026#34;Never\u0026#34;); Throw 一个运行即报错的流：\n1 2 3 Observable.Throw\u0026lt;ApplicationException\u0026gt;( new ApplicationException(\u0026#34;something bad happened\u0026#34;)) .SubscribeConsole(\u0026#34;Throw\u0026#34;); 输出：\n1 2 Throw - OnError: System.ApplicationException: something bad happened Empty 1 2 Observable.Empty\u0026lt;string\u0026gt;() .SubscribeConsole(\u0026#34;Empty\u0026#34;); 输出：\n1 Empty - OnCompleted() ","date":"2022-08-10T00:00:00Z","image":"https://kyocius.github.io/p/rx-magic-3/head_hu60daa3e750dae8efe162b164d024055e_222411_120x120_fill_box_smart1_3.png","permalink":"https://kyocius.github.io/p/rx-magic-3/","title":"Rx.NET 响应式编程指北 03 - 深入流的创建"},{"content":"前言 这一章是独立于正式章节的番外，补充一下 C# 函数式编程（Functional Programming）以及流式接口（Fluent API）的知识。\n等等，我们不是在学 Rx.NET 吗，怎么又跑到函数式了？ (＃°Д°)\n你 先 别 急，二者并不冲突。\nRx.NET 提供的方法大部分都是函数式的，比如我们上一章学到的 FromEventPattern 方法，就是一个高阶函数（High-Order Function），因为它的参数也是函数。\n有些老古董 Java 程序员认为，C# 和 Java 一样都是纯面向对象语言（Pure OOP），这是完全错误的。经过二十年的发展，C# 早已进化成一门多范式语言了。\n函数式编程 那么如何用 C# 编写函数式代码呢？\n回顾一下基础知识吧。\n委托 Delegate 为了传递函数，C# 老早就加入了委托特性：\n1 public delegate bool MyDelegateType (string first, string second); 在上面的代码中，我们创建了一个名为 MyDelegateType 的委托类型。\n我们这样为委托赋值：\n1 2 3 4 MyDelegateType myDel; myDel += \u0026lt;一些函数\u0026gt;; myDel(\u0026#34;first\u0026#34;, \u0026#34;second\u0026#34;); // 这样调用 匿名方法 Anonymous methods 1 2 3 4 myDel = delegate (string first, string second) { return first.Length == second.Length; } Lambda 表达式 1 2 3 4 5 // 👇 这就是 lambda MyDelegateType x = (s1,s2) =\u0026gt; s1 == s2; // 👇 匿名函数 MyDelegateType y = delegate (string s1,string s2) { return s1 == s2; }; Func 和 Action 这俩都是 .NET 预定义好的标准委托类型。\n也就是说别傻乎乎地自己定义委托类型啦，用它俩就好了。\n.NET 预定义了 17 种 Func 和 Action 委托，全放在 System 名称空间下。\nAction Action 用于无返回值的函数委托。\n看看定义：\n1 2 3 4 // 👇 无参 public delegate void Action(); // 👇 两个参数 public delegate void Action\u0026lt;in T1, in T2\u0026gt;(T1 arg1, T2 arg2); 简单使用：\n1 2 3 4 5 6 7 8 9 10 11 public static void ForEach\u0026lt;T\u0026gt;(IEnumerable\u0026lt;T\u0026gt; collection, Action\u0026lt;T\u0026gt; action) { foreach (var item in collection) { action(item); } } // 👇 完整使用 ForEach(new[] { \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34; }, n =\u0026gt; Console.WriteLine(n)); // 👇 省略形式 ForEach(new[] { \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34; }, Console.WriteLine); Func Func 用于有返回值的函数委托。\n看看定义：\n1 2 public delegate TResult Func\u0026lt;out TResult\u0026gt;(); public delegate TResult Func\u0026lt;in T1,…,T16, out TResult\u0026gt;(T1 arg,…,T16 arg16); 简单使用：\n1 2 3 4 5 6 7 8 9 10 11 public static void ForEach\u0026lt;T\u0026gt;(IEnumerable\u0026lt;T\u0026gt; collection, Action\u0026lt;T\u0026gt; action, Func\u0026lt;T, bool\u0026gt; predicate) { foreach (var item in collection) { if (predicate(item)) { action(item); } } } 懒加载 Lazy\u0026lt;T\u0026gt; 我们来看看 Func 作为工厂函数的作用吧。\n你有一个很耗时的类：\n1 2 3 4 class HeavyClass { // 初始化非常耗时 } 你还有个类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ThinClass { private HeavyClass _heavy; public HeavyClass TheHeavy { get { if (_heavy == null) { _heavy = new HeavyClass(); // 延迟加载时间 } return _heavy; } } public void SomeMethod() { var myHeavy = TheHeavy; // 省略后面的使用 } } 我们可以看到这就是在 Java 中常见的构建模式。\n那如果你有 10 个需要延迟加载的属性呢？像这样一一手写 get 方法未免也太折磨了。\n太笨了，在 C# 中才不这么做！\n我们来使用 System 空间下的懒加载类 Lazy\u0026lt;T\u0026gt;：\n1 2 3 4 5 6 7 8 9 10 class ClassWithLazy { Lazy\u0026lt;HeavyClass\u0026gt; _lazyHeavyClass = new Lazy\u0026lt;HeavyClass\u0026gt;(); public void SomeMethod() { var myHeavy = _lazyHeavyClass.Value; //使用 myHeavy } } 那如果 HeavyClass 类的构造方法需要参数咋办？\n传递个 Func 给它：\n1 2 3 4 5 6 Lazy\u0026lt;HeavyClass\u0026gt; _lazyHeavyClass = new Lazy\u0026lt;HeavyClass\u0026gt;(() =\u0026gt; { var heavy = new HeavyClass(...); ... return heavy; }); 流式接口 Fluent API 流式接口（Fluent API）是一种方法调用风格：\n1 2 3 4 5 6 7 StringBuilder sbuilder = new StringBuilder(); var result = sbuilder .AppendLine(\u0026#34;Fluent\u0026#34;) .AppendLine(\u0026#34;Interfaces\u0026#34;) .AppendLine(\u0026#34;Are\u0026#34;) .AppendLine(\u0026#34;Awesome\u0026#34;) .ToString(); 看看破晓的 ModuleLauncher.Re 是怎么写的吧：破晓打钱！\n1 2 3 var process = await minecraft.WithAuthentication(\u0026#34;\u0026lt;player\u0026gt;\u0026#34;) .WithJava(@\u0026#34;\u0026lt;java\u0026gt;\u0026#34;) .LaunchAsync(); 接下来我们动手写一个流式接口。\n我们平常为 List 添加元素：\n1 2 3 4 var words = new List\u0026lt;string\u0026gt;(); words.Add(\u0026#34;This\u0026#34;); words.Add(\u0026#34;Feels\u0026#34;); words.Add(\u0026#34;Weird\u0026#34;); 不够优雅！用流式接口写个扩展方法：\n1 2 3 4 5 6 7 8 public static class ListExtensions { public static List\u0026lt;T\u0026gt; AddItem\u0026lt;T\u0026gt;(this List\u0026lt;T\u0026gt; list, T item) { list.Add(item); return list; } } 现在我们就可以使用方法链了：\n1 2 3 4 var words = new List\u0026lt;string\u0026gt;(); words.AddItem(\u0026#34;This\u0026#34;) .AddItem(\u0026#34;Feels\u0026#34;) .AddItem(\u0026#34;Weird\u0026#34;); Awesome！瞬间就简洁多了。\n","date":"2022-08-09T00:00:00Z","image":"https://kyocius.github.io/p/rx-magic-ex/head_hu60daa3e750dae8efe162b164d024055e_222411_120x120_fill_box_smart1_3.png","permalink":"https://kyocius.github.io/p/rx-magic-ex/","title":"Rx.NET 响应式编程指北 Ex - 函数式思想 \u0026 流式接口"},{"content":"前言 在上一章里，我们学习了响应式的基本概念。在这一章节，我们将编写一个股票监控程序。首先我们将使用传统的 .NET 事件系统来写一次，之后再通过 Rx 来重构。\n传统事件写法 先编写一个类，其中只有一个事件属性： 1 2 3 4 class StockTicker { public event EventHandler\u0026lt;StockTick\u0026gt; StockTick; } 编写一个类包含我们的数据： 1 2 3 4 5 class StockTick { public string QuoteSymbol { get; set; } public decimal Price { get; set; } } 创建一个类来监听变化，并订阅事件： 1 2 3 4 5 6 7 8 class StockMonitor { public StockMonitor(StockTicker ticker) { ticker.StockTick += OnStockTick; // OnStockTick 注册事件 } ... } 因为我们需要比较股票价格的变化，所以我们可以通过字典来存储先前的股票数据。编写一个新类： 1 2 3 4 5 6 7 8 9 10 class StockInfo { public StockInfo(string symbol, decimal price) { Symbol = symbol; PrevPrice = price; } public string Symbol { get; set; } public decimal PrevPrice { get; set; } } 之后你可以在 StockMonitor 中声明一个 StockInfo 类型的属性。\n每当股票变化时，OnStockTick 就会被调用。因此，我们的应用还要实现一个新旧数据比较的功能。我们将使用 TryGetValue 方法。当我们想要的值存在时，这个方法会返回一个 true。在 StockMonitor 中编写以下代码： 1 2 3 4 5 6 7 8 9 var _stockInfos = new Dictionary\u0026lt;string, StockInfo\u0026gt;(); void OnStockTick(object sender, StockTick stockTick) { StockInfo stockInfo; var quoteSymbol = stockTick.QuoteSymbol; var stockInfoExists = _stockInfos.TryGetValue(quoteSymbol, out stockInfo); ... } 如果一个股票数据存在，我们就可以比较大小了： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const decimal maxChangeRatio = 0.1m; ... var quoteSymbol = stockTick.QuoteSymbol; var stockInfoExists = _stockInfos.TryGetValue(quoteSymbol, out stockInfo); if (stockInfoExists) { var priceDiff = stockTick.Price-stockInfo.PrevPrice; // 变化的百分比 var changeRatio = Math.Abs(priceDiff/stockInfo.PrevPrice); if (changeRatio \u0026gt; maxChangeRatio) { // 简单打印个信息，用的是 C# 6.0 以前的写法 Console.WriteLine(\u0026#34;Stock:{0} has changed with {1} ratio, Old Price:{2} New Price:{3}\u0026#34;, quoteSymbol, changeRatio, stockInfo.PrevPrice, stockTick.Price); } //保存这个新数据 _stockInfos[quoteSymbol].PrevPrice = stockTick.Price; } 那如果我们不想要订阅股票消息了咋办？幸运的是 .NET 提供了方法来干这个活。在 StockMonitor 里编写以下方法： 1 2 3 4 5 public void Dispose() { _ticker.StockTick -= OnStockTick; _stockInfos.Clear(); } 写一点假数据，测试一下结果： 1 2 3 4 5 6 7 8 9 // 瞎编的 Symbol: \u0026#34;MSFT\u0026#34; Price: 100 Symbol: \u0026#34;INTC\u0026#34; Price: 150 Symbol: \u0026#34;MSFT\u0026#34; Price: 170 Symbol: \u0026#34;MSFT\u0026#34; Price: 195 // 运行结果 Stock:MSFT has changed with 0.7 ratio, Old Price:100 New Price:170 Stock:MSFT has changed with 0.15 ratio, Old Price:170 New Price:195.5 哇哦，感觉还不错嘛！\n但是这么写就一点问题没有吗？\n并发问题 我们的程序运行起来没啥问题，但背后有个严重漏洞：\n不是并发的！\n如果 StockMonitor 运行期间又有新的股票变化咋办？\n很抱歉，只能等着第一次程序结束。\n线程不安全 虽然我们的 StockInfo 字典支持多读者（Multiple Readers）同时读取，但当我们读取字典时字典正在被修改，那么就会报错。\n这是你可能会说，可以改用 .NET 提供的无锁 ConcurrentDictionary 呀！这样就不报错了。\n但是，那我们每次比较的新值又是谁？是修改前的，还是修改后的？\n你可能又会说，可以使用线程锁（Thread Lock）来阻塞两个同时发生的线程的其中一个。\n可是如果资源不及时释放，又很容易导致死锁问题。\n响应式写法 使用 Rx 的话，传统事件写法暴露出的问题可以通过更简单的方式解决。\n安装 Rx.NET 你都看到这里了，相信咋安装根本不用我教你。\nRx.NET 放在 System.Reactive 名称空间下。\n事件转换 Rx.NET 提供了好用的 FromEventPattern 方法，帮助我们将事件转换成可观察对象（Observable）：\n1 2 3 4 IObservable\u0026lt;EventPattern\u0026lt;StockTick\u0026gt;\u0026gt; ticks = Observable.FromEventPattern\u0026lt;EventHandler\u0026lt;StockTick\u0026gt;, StockTick\u0026gt;( h =\u0026gt; ticker.StockTick += h, h =\u0026gt; ticker.StockTick -= h); 谔谔，看不懂捏\u0026hellip;\n那来看一下这个方法的定义吧：\n1 FromEventPattern\u0026lt;TDelegate,TEventArgs(Action\u0026lt;TDelegate\u0026gt;addHandler, Action\u0026lt;TDelegate\u0026gt; removeHandler) TDelegate 是匹配事件的委托 → EventHandler\u0026lt;StockTick\u0026gt; TEventArgs 就是 EventArgs → StockTick addHandler 和 removeHandler 一般就直接写成 Lambda 表达式的形式 因为我们只关心传入的 EventArgs，所以代码可以改写成：\n1 2 3 4 var ticks = Observable.FromEventPattern\u0026lt;EventHandler\u0026lt;StockTick\u0026gt;, StockTick\u0026gt;( h =\u0026gt; ticker.StockTick += h, h =\u0026gt; ticker.StockTick -= h) .Select(tickEvent =\u0026gt; tickEvent.EventArgs); 数据处理 现在你已经有了一个可观察的数据流了，我们将围绕它展开查询操作，就像 LINQ 一样。\n分组 Group 我们试着通过 Symbol 来为每支股票分组：\n1 2 3 4 5 6 // 查询语句形式 from tick in ticks group tick by tick.QuoteSymbol into company // 函数形式 ticks.GroupBy(tick =\u0026gt; tick.QuoteSymbol); 分批 Buffer Buffer 用于同组内再分批（Batch）。\n在这里是同组内数据两两前后比较：\n1 2 3 4 5 from tick in ticks group tick by tick.QuoteSymbol into company from tickPair in company.Buffer(2, 1) let changeRatio = Math.Abs((tickPair[1].Price - tickPair[0].Price) / tickPair[0].Price) 最后全部的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const decimal maxChangeRatio = 0.1 m; var drasticChanges = from tick in ticks group tick by tick.QuoteSymbol into company from tickPair in company.Buffer(2, 1) let changeRatio = Math.Abs((tickPair[1].Price - tickPair[0].Price) / tickPair[0].Price) where changeRatio \u0026gt; maxChangeRatio select new DrasticChange() { Symbol = company.Key, ChangeRatio = changeRatio, OldPrice = tickPair[0].Price, NewPrice = tickPair[1].Price }; 消费数据 1 2 3 4 5 6 7 8 _subscription = drasticChanges.Subscribe(change =\u0026gt; { Console.WriteLine($\u0026#34;Stock:{change.Symbol} has changed with {change.ChangeRatio} ratio, Old Price: {change.OldPrice} New Price: {change.NewPrice}\u0026#34;); }, ex =\u0026gt; { /* 处理错误 */}, () =\u0026gt; {/* 响应任务完成 */}); 取消订阅 1 2 3 4 public void Dispose() { _subscription.Dispose(); } 同步流 还记得我们之前使用事件系统的问题吗？\n异步 IO 会导致线程不安全。\n因此我们要将我们的 ticks 可观察数据流转换成同步的：\n1 2 3 4 5 var ticks = Observable.FromEventPattern\u0026lt;EventHandler\u0026lt;StockTick\u0026gt;, StockTick\u0026gt;( h =\u0026gt; ticker.StockTick += h, h =\u0026gt; ticker.StockTick -= h) .Select(tickEvent =\u0026gt; tickEvent.EventArgs) .Synchronize(); 总览代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class RxStockMonitor : IDisposable { private IDisposable _subscription; public RxStockMonitor(StockTicker ticker) { const decimal maxChangeRatio = 0.1m; var ticks = Observable.FromEventPattern\u0026lt;EventHandler\u0026lt;StockTick\u0026gt;, StockTick\u0026gt;( h =\u0026gt; ticker.StockTick += h, h =\u0026gt; ticker.StockTick -= h) .Select(tickEvent =\u0026gt; tickEvent.EventArgs) .Synchronize(); var drasticChanges = from tick in ticks group tick by tick.QuoteSymbol into company from tickPair in company.Buffer(2, 1) let changeRatio = Math.Abs((tickPair[1].Price - tickPair[0].Price)/tickPair[0].Price) where changeRatio \u0026gt; maxChangeRatio select new { Symbol = company.Key, ChangeRatio = changeRatio, OldPrice = tickPair[0].Price, NewPrice = tickPair[1].Price }; _subscription = drasticChanges.Subscribe(change =\u0026gt; { WriteLine($\u0026#34;Stock:{change.Symbol} has changed with {change.ChangeRatio} ratio, Old Price: {change.OldPrice} New Price: {change.NewPrice}\u0026#34;); }, ex =\u0026gt; { /* 处理错误 */}, () =\u0026gt;{/* 响应任务完成 */}); } public void Dispose() { _subscription.Dispose(); } } Rx 的优点 我们已经用两种方式编写了这个股票监控程序，是时候比较两种写法了。\n代码更紧凑：所有逻辑集中在一起\n更少的资源占用：Rx 几乎没有资源处理的开销\n强大的操作符：Rx 最明显的优势\n更简单地同步：一个 Synchronize 方法足矣\n","date":"2022-08-08T00:00:00Z","image":"https://kyocius.github.io/p/rx-magic-2/head_hu60daa3e750dae8efe162b164d024055e_222411_120x120_fill_box_smart1_3.png","permalink":"https://kyocius.github.io/p/rx-magic-2/","title":"Rx.NET 响应式编程指北 02 - 基本使用"},{"content":"前言 最近刚读了 Rx.NET in Action，学到的新概念非常多，担忧自己会日渐遗忘，觉得有必要写一篇博客记录一下，说不定也能帮到一些志同道合的朋友。\n本系列将会使用我深爱的 C# 语言和 Rx.NET 框架来讲解响应式编程（Reactive Programming）的魔法 ╰(°▽°)╯\n背景知识 C# 中的委托、泛型、事件以及 LINQ 等概念 Rx = Reactive Extension Rx 是由微软旗下一个实验室发起的 巨硬大法好 响应式概念 Rx 到底是干啥的？\n首先来看看微软的解释：Rx = Observables + LINQ + Schedulers。谔谔，啥玩意儿？\n那看看大佬怎么解释的吧：Rx = 处理异步数据流。这个解释还行，但还是不明白。\n这里是更通俗的解释：\n1 2 3 var a = 1; var b = 2; var c = a + b; // c 的值显然为 3 当你改变 a 或者 b 值的时候，按照我们以前的思维，c 的值并不会随之发生变化。\n如果我们想要 c 的值随之而改变呢？很简单，快快使用 Rx！\n可观察对象 Observable 1 2 3 4 public interface IObservable\u0026lt;T\u0026gt; { IDisposable Subscribe(IObserver\u0026lt;T\u0026gt; observer); } 接口只有一个方法 Subscribe，返回 IDisposable 对象（代表着订阅事件本身） Observable 持有 Observer 的集合，在值改变时随时通知它们 IDisposable 对象可以通过 Dispose 方法随时取消订阅 观察者 Observer 观察者的源码其实也很简单。\n1 2 3 4 5 6 public interface IObserver\u0026lt;T\u0026gt; { void OnNext(T value); void OnError(Exception error); void OnCompleted(); } OnNext 方法定义当观测的值出现变化时，该做什么（类比迭代） OnError 方法定义它出现错误时该做什么 OnCompleted 方法定义它任务完成时该做什么 值得注意的是：发生错误时，数据流就会中断 操作符 Operator Rx 带来了海量的操作符，帮助我们分类、查找、转换数据。\nRx.NET 的操作符与其它语言的 Rx 不同的是，操作符采用了原汁原味的 LINQ 风格。\n下面来点简单实例：\n1 2 3 4 5 6 7 8 IObservable\u0026lt;string\u0026gt; strings= ... // 数据源 IDisposable subscription = strings // 一个 IDisposable 代表了订阅事件本身 .Where(str =\u0026gt; str.StartsWith(\u0026#34;A\u0026#34;)) .Select(str =\u0026gt; str.ToUpper()) .Subscribe(...); // 传入 Observer 或直接传 OnNext 方法 subscription.Dispose(); // 上面说过了，可以随时取消订阅 上面的代码读起来是不是很流畅？\n其实第一行省略了如何创建可观察数据源，专注于操作符本身，要不然太劝退了。\n如何创建可观察的数据源将在后面的章节讲解。\n理解事件和流 Events \u0026amp; Streams 事件非常好理解，比如我们点击一个按钮就是一个事件。\n在 C# 中，事件由数据源「Event Source」和处理器「Event Handler」组成。\n在 Rx 中，「Event Source」对应「Observable」而「Event Handler」对应「Observer」。\n万物皆流 A data stream is like a hose: every drop of water is a data packet that needs to go through stations until it reaches the end. Your data also needs to be filtered and transformed until it gets to the real handler that does something useful with it.\n上面这段 Quote 来自 Rx.NET in Action，大致的意思就是数据就像水管子一样，我们通过操作符过滤水流，最后通过喷头将水流传播。\n我认为这是响应式的核心概念。只要你想持续地监听某数据的变化，那么使用 Rx 让数据变成可观察流，绝对是个好主意。\n","date":"2022-08-07T00:00:00Z","image":"https://kyocius.github.io/p/rx-magic-1/head_hu60daa3e750dae8efe162b164d024055e_222411_120x120_fill_box_smart1_3.png","permalink":"https://kyocius.github.io/p/rx-magic-1/","title":"Rx.NET 响应式编程指北 01 - 基础概念"}]