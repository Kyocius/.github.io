---
title:  笨方法学 C 附加题不完全解答
date: 2024-01-23
draft: false
slug: clang-review
description: Partial Answers for Learn C The Hard Way
categories:
    - 编程
tags:
    - Clang
    - ysyx
image: head.png

---
## 前言

其实笔者并不喜欢 C 语言，但是为了应试只能硬着头皮学了。

笔者在复习 C 语言时，看到一本书叫《笨方法学 C》，其以练习题的方式串联起 C 语言的大致语法。

本文尝试解答书后附加题，有的章节太简单就略过了。

## 练习10：字符串数组和循环

1. 如何使用 `,`（逗号）字符来在for循环的每一部分中，`;`（分号）之间分隔多条语句？

```c
for (i = 0, j = 10; i < 10; i++, j--)
```

2. 查询 `NULL` 是什么东西，看看它会打印出什么？

在 C 语言中，NULL 是一个宏定义，通常用于表示指针不指向任何有效的对象或地址。NULL 的确切定义可能因编译器和平台而异，但通常它被定义为 `(void *)0`，即一个转换为 `void` 指针类型的零值。

当你尝试打印一个指向 `NULL`的指针时，结果会取决于你是如何打印它的。在 C 语言中，如果你使用 `%p` 格式化标志（用于打印指针地址）和 `printf` 函数，通常会打印出一个表示空指针的值，通常是 `(nil)` 或者 `0x0`，具体取决于编译器和平台。

3. 看看你是否能在打印之前将 `states` 的一个元素赋值给 `argv` 中的元素，再试试相反的操作？

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    
    
    char *states[] = {"California", "Oregon", "Washington", "Texas"};

    // 将states的一个元素赋值给argv的一个元素
    // 注意：这通常不是个好主意，因为argv通常不应被修改
    if (argc > 1) {
        argv[1] = states[0];
        printf("argv[1] is now %s\n", argv[1]);
    }

    // 将argv的一个元素赋值给states的一个元素
    states[0] = argv[0];
    printf("states[0] is now %s\n", states[0]);

    return 0;
}
```
## 练习16：结构体和指向它们的指针

1. 如何在栈上创建结构体，就像你创建任何其它变量那样？

2. 如何使用 `x.y` 而不是 `x->y` 来初始化结构体？

对于前两个问题其实非常好解答。只要把变量 `x` 设置成非指针即可。

3. 如何不使用指针来将结构体传给其它函数？

C 语言**不可能**不使用指针传递结构体本身。所以这道题的意思就浅显地指，把参数的 `*` 去掉你会不会...

## 练习17：堆和栈的内存分配

> 对于现在你们这些年轻人来说，编程简直太容易了。如果你玩玩 Ruby 或者 Python 的话，只要创建对象或变量就好了，不用管它们存放在哪里。

理清内存最简单原则：如果你的变量并不是从 `malloc` 中获取的，也不是从一个从 `malloc` 获取的函数中获取的，那么它在栈上。

1. `strncpy` 有什么设计缺陷？

```c
char *strncpy(char *dest, const char *src, size_t n)
```
`strcpy` 函数不会向 `dest` 追加 `\0`，也就是字符串没有了结束，可能会造成内存非法访问。

2. C 如何打包结构体？结构体添加一些字段之后的新大小？

在 C 语言中，结构体的默认对齐方式通常是按照结构体成员中占用内存最大的数据类型进行对齐。这被称为“最大成员对齐”或“自然对齐”。

结构体的总大小是其最大对齐成员的大小的整数倍。

## 练习18：函数指针

函数指针编写窍门：

- 编写一个普通的函数声明：`int callme(int a, int b)`
- 将函数用指针语法包装：`int (*callme)(int a, int b)`
- 将名称改成指针名称：`int (*compare_cb)(int a, int b)`
