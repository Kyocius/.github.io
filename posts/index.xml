<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 游尔曼斯克</title>
    <link>https://kyocius.github.io/posts/</link>
    <description>Recent content in Posts on 游尔曼斯克</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>Kyocius. 本站遵循 CC-BY-NC 4.0 协议</copyright>
    <lastBuildDate>Tue, 02 Apr 2024 14:13:00 +0800</lastBuildDate><atom:link href="https://kyocius.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>近况，困顿与精神符号</title>
      <link>https://kyocius.github.io/posts/casual-writting/2024-04-02-confusion/</link>
      <pubDate>Tue, 02 Apr 2024 14:13:00 +0800</pubDate>
      
      <guid>https://kyocius.github.io/posts/casual-writting/2024-04-02-confusion/</guid>
      <description>大学生活没有想象中美好。形式的、毫无意义的活动和报告，在侵蚀我的热情，虽然我早知会如此。从前那些不以为意的选择和肤浅的见解，在这段时间成为了箍紧我的枷锁。我很不愿意承认自己会因为一些小事大发牢骚，但往往心中裂痕淌出的水滴，会在种种现实的挫伤下，变成决堤的洪流。
我想，是时候梳理这股无谓的洪流了。
上学期挂了学分最高的数学分析，下学期经过补考 GPA 能开出 3.66 但是均分依然很低，说实话我依然在疑惑这个绩点如何换算来的，比预期高很多。但在这所谓的○班里，GPA 比我高的比比皆是。在上大学之前我就拜读过 《上海交通大学生存手册》进而得知绩点不应该是大学生活的圭臬，这反而成为了深夜的自我安慰剂，每次摆烂后扎入皮肤，一瞬间「毕竟绩点才不是我所追求的」之类的话随着血液涌上脑海。但事实上我除了在内耗和摸鱼之间反反复复之外，真正学的东西少之又少。
如果再往思维的更深处挖去，我发现是我那可怜又可笑的虚荣心。从小到大，自认为素养不低、读书不少，但我那如同木制高台的价值观依然建立在物欲与攀比的淤泥里。人人都想要高绩点，但无非是为了更好的升学，升入更高档次的学府，获得更高档次的工作。但越是跟随这实验班的培养方案学习，我越是觉得自己不是学院想要的那类「数理人才」，名为计算机拔尖班却将 CS 课程推后，也发现了通信没有想象中感兴趣。重视基础学科教育并没有问题，但这好像也阻挠了○班学生出去实习的可能性，毕竟科研和工业界大相径庭。头部的学生依然如鱼得水、潇洒自如，着实令我自惭形秽。
每至深夜，「我到底想要什么？」的疑问在脑海里挥之不去。我说我想要他人的羡艳的目光，那为什么当初不选择诸如武大南开之类的综合名校？我又说我想要成为享誉学术界的大拿，那为什么连基础课程的均分都达不到，而且是已经身在被制裁的院校？后来我发现我真正喜欢的安逸的氛围，想去美国的原因只是因为迟先生所在的 CMU 这类名校。我也只能叹息每个选择都和家庭紧密相关。人在不得志的时候会郁郁反其本，此话不假。我明明站在向前的单行道上，却依然踌躇四顾。
我需要一个精神符号。那种能推着你走的，偶像似的符号，又或者那种可以带给人强烈归属感的符号。我有次听到中国人民大学哲学院的副教授王小伟说：「符号是具有魔力的，符号可以产生价值。」我在知乎上刷到一位 Blackmore 信通院学长，因为 10043 法令只能放弃了 Columbia 的录取，去 CUHK 做了两年 RA，在 Edinburgh 又读了两年 MRes。最后成功申请到了 Cambridge 的 PhD，却又因为 ATAS 没过，再次被拒之门外。先不论我能否达到学长的成就，单是看到他被如此对待就不免心痛，如果他能一路顺遂，能取得世俗意义上更大的成功。不过从他的动态中看出，他好像已找到了另外一条路留在英国，并且过得很开心。
也许我也能找到自己的路吧。我总想活在他人的荫蔽下，走别人踩过的道路，认为前人能一路披荆斩棘，我也定能过关斩将。但我和他人的家庭条件、心理状态、抗压能力以及机遇又能一样吗？我以前总以为自己收集信息的能力很强，可以自己区别利弊、规避风险。但当我回头看的时候，留给我已经没有多少选择了。
对于现实的动力，大概就是攒钱去加拿大吧。现在的梦校就是 Waterloo 和 UBC，并且想去一些小而美的初创公司干活，成为更有趣的人。不过等我毕业的时候，世界又是什么格局，会不会形成更深的沟壑，又有谁会知道呢？
发现自己开始对 Blues 和 Neo R&amp;amp;B 着迷，有时候看着王家卫拍的电影出神。那种朦胧的、梦幻的音乐，抽帧的、缀以暗色的场景，可能正影射着我对当下的印象吧。也许会被旁人骂成赛博文青，但对我来说已毫无所谓。
从前我是不相信 MBTI 的，因为人，尤其是人的思维，是无法用简单几十道直白的 quiz 来定义的。我曾把这句话告诉了当时正在追求的女孩，现在想来真是蠢到极致，和自己没有太多共鸣的人聊天，大部分时间都是我在迎合，很累且无益。不过我更加确信了我是一个外表热情乐观洋溢，实则容易阴郁和自弃的人格。我也认定自己虽看惯卑劣和老旧，内心仍不舍浪漫主义。我觉得这会是日后我与众人的不同。
言尽于此，祝我的未来无限可能、步入正轨，也祝各位看客生活美满幸福。</description>
    </item>
    
    <item>
      <title>数电与计算机体系结构 01：入门</title>
      <link>https://kyocius.github.io/posts/chip-design/digital-design-and-comp-arch/ddca-1/</link>
      <pubDate>Fri, 02 Feb 2024 11:25:05 +0800</pubDate>
      
      <guid>https://kyocius.github.io/posts/chip-design/digital-design-and-comp-arch/ddca-1/</guid>
      <description>前言 此系列文章是《Digital Design and Computer Architecture: RISC-V Edition》的读书笔记。
数字抽象的深层含义 数字电路使用离散值，而物理值一般是连续的，所以电路设计者要想办法把离散值和连续值对应起来。
供电电压 零伏特电压一般指的是接地（GND）。从上世纪 70 年代起，供电电压从 5V 降到了 1.2V 以下。
逻辑电平 逻辑电平是指数字电路中电信号的电压水平，用于表示逻辑状态。在数字电路中，通常将电压分为两个离散的状态，分别代表逻辑值 0 和逻辑值 1。
噪声裕度 表示可以容忍的电压差值：
$$ NM_{L} = V_{IL} - V_{OL} $$ $$ NM_{H} = V_{OH} - V_{IH} $$
直流传输特性 将输入电压作为自变量，将输出电压作为因变量，抽象出一个函数。其形成的图像很有特点，叫作直流传输特性（DC Transfer Characteristics）。图像请参阅原书。
静态电路法则 静态电路法则要求，在给定逻辑上有效的输入情况下，每个电路元件都将产生逻辑上有效的输出。
为了提高生产力，诞生了四个逻辑家族：
TTL CMOS LVTTL LVCMOS </description>
    </item>
    
    <item>
      <title>笨方法学 C 附加题不完全解答</title>
      <link>https://kyocius.github.io/posts/chip-design/clang-review/</link>
      <pubDate>Tue, 23 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://kyocius.github.io/posts/chip-design/clang-review/</guid>
      <description>前言 笔者撰写本文时还在上大一，数据结构基础几乎为零，所以会有一些可笑的问题和不合时宜的吐槽。
本文尝试解答书后附加题，有的章节太简单就略过了。
练习10：字符串数组和循环 如何使用 ,（逗号）字符来在for循环的每一部分中，;（分号）之间分隔多条语句？ for (i = 0, j = 10; i &amp;lt; 10; i++, j--) 查询 NULL 是什么东西，看看它会打印出什么？ 在 C 语言中，NULL 是一个宏定义，通常用于表示指针不指向任何有效的对象或地址。NULL 的确切定义可能因编译器和平台而异，但通常它被定义为 (void *)0，即一个转换为 void 指针类型的零值。
当你尝试打印一个指向 NULL的指针时，结果会取决于你是如何打印它的。在 C 语言中，如果你使用 %p 格式化标志（用于打印指针地址）和 printf 函数，通常会打印出一个表示空指针的值，通常是 (nil) 或者 0x0，具体取决于编译器和平台。
看看你是否能在打印之前将 states 的一个元素赋值给 argv 中的元素，再试试相反的操作？ #include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { char *states[] = {&amp;#34;California&amp;#34;, &amp;#34;Oregon&amp;#34;, &amp;#34;Washington&amp;#34;, &amp;#34;Texas&amp;#34;}; // 将states的一个元素赋值给argv的一个元素 // 注意：这通常不是个好主意，因为argv通常不应被修改 if (argc &amp;gt; 1) { argv[1] = states[0]; printf(&amp;#34;argv[1] is now %s\n&amp;#34;, argv[1]); } // 将argv的一个元素赋值给states的一个元素 states[0] = argv[0]; printf(&amp;#34;states[0] is now %s\n&amp;#34;, states[0]); return 0; } 练习16：结构体和指向它们的指针 如何在栈上创建结构体，就像你创建任何其它变量那样？ 如何使用 x.</description>
    </item>
    
    <item>
      <title>写给 C# 开发者的 F# 光速入门教程</title>
      <link>https://kyocius.github.io/posts/dotnet/fsharp-for-csharp-devs/</link>
      <pubDate>Fri, 26 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://kyocius.github.io/posts/dotnet/fsharp-for-csharp-devs/</guid>
      <description>本文翻译自托管在 GitHub 上的 2fsharp 开源项目
译版仅发表在知乎和 本人博客 上，未经授权禁止转载
这个教程是基于实例来讲解的，将会花费你 15-30 分钟的时间。
你将会学到 F# 这门语言 80% 的特性！
例 1：基本函数声明与实现 public int GiveMeTheLength(string input) { // 单行注释 var result = input.Length; /* 多行注释 */ return result; } 变成了
let GiveMeTheLength(input) = // 单行注释 let result = input.Length (* 多行注释 *) result 所有东西都是默认为 public 的，除非你显式声明 private 修饰符。 关键字 var 变成了 let（不仅仅用来声明变量，还用来声明函数）。 你不再需要 return 关键字。函数的最后一行就是返回值。 不再需要花括号，使用 4 格（或者 2 格）缩进，就像 Python 一样。 不再需要分号来标志一行结束。 类型声明是可选的，除了极少数情况编译器无法推断类型。 单行注释和 C# 相同，但是多行注释使用括号而不是斜杠。 如果你想要声明类型，需要这样写：</description>
    </item>
    
    <item>
      <title>C# 进阶小册 - 并发与异步</title>
      <link>https://kyocius.github.io/posts/dotnet/advanced-csharp/</link>
      <pubDate>Mon, 15 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://kyocius.github.io/posts/dotnet/advanced-csharp/</guid>
      <description>前言 就是太久没写异步，有的用法忘了。所以写篇博客回顾一下。
线程 Thread 虽然在 C# 中 Task 的使用频率远超直接使用线程，但是有关线程的概念还是要复习一下的。
才不是因为我全忘了
创建线程 Create a Thread using System; using System.Threading; var t = new Thread(WriteY); t.Start(); for (var i = 0; i &amp;lt; 1000; i++) { Console.Write(&amp;#34;x&amp;#34;); } void WriteY() { for (var i = 0; i &amp;lt; 1000; i++) Console.Write(&amp;#34;y&amp;#34;); } //输出： xxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyy... xxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyy... xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyy... yyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxx... 我们可以通过 Name 属性来访问线程的名字：
WriteLine(Thread.CurrentThread.Name); Join 与 Sleep 你可以使用 Join 方法来等待线程结束：
Thread t = new Thread(Go); t.</description>
    </item>
    
    <item>
      <title>Rx.NET 响应式编程指北 03 - 深入流的创建</title>
      <link>https://kyocius.github.io/posts/dotnet/reactive/rx-magic-3/</link>
      <pubDate>Wed, 10 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://kyocius.github.io/posts/dotnet/reactive/rx-magic-3/</guid>
      <description>前言 之前我们见识了 Rx.NET 的基本用法，把 .NET 事件转化成了可观察数据流，并且补充了一些拓展知识（Ex），现在我们要接着深入 Rx.NET 的核心技术了。
普通数据流 还记得吗，IObservable 接口只有一个方法 Subscribe，是 Rx.NET 的基础。
我们将试着打造一个即时通讯系统。
实现 IObservable 接口 在实际的开发中，非常不推荐直接实现 IObservable 接口，但是理解这个流程对我们的学习很有帮助。
using System; using System.Reactive.Disposables; public class NumbersObservable : IObservable&amp;lt;int&amp;gt; { private readonly int _amount; public NumbersObservable(int amount) { _amount = amount; } public IDisposable Subscribe(IObserver&amp;lt;int&amp;gt; observer) { for (int i = 0; i &amp;lt; _amount; i++) { observer.OnNext(i); } observer.OnCompleted(); return Disposable.Empty; } } 实现 Observer 接口 public class ConsoleObserver&amp;lt;T&amp;gt; : IObserver&amp;lt;T&amp;gt; { private readonly string _name; public ConsoleObserver(string name=&amp;#34;&amp;#34;) { _name = name; } public void OnNext(T value) { Console.</description>
    </item>
    
    <item>
      <title>Rx.NET 响应式编程指北 Ex - 函数式思想 &amp; 流式接口</title>
      <link>https://kyocius.github.io/posts/dotnet/reactive/rx-magic-ex/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://kyocius.github.io/posts/dotnet/reactive/rx-magic-ex/</guid>
      <description>前言 这一章是独立于正式章节的番外，补充一下 C# 函数式编程（Functional Programming）以及流式接口（Fluent API）的知识。
等等，我们不是在学 Rx.NET 吗，怎么又跑到函数式了？ (＃°Д°)
你 先 别 急，二者并不冲突。
Rx.NET 提供的方法大部分都是函数式的，比如我们上一章学到的 FromEventPattern 方法，就是一个高阶函数（High-Order Function），因为它的参数也是函数。
有些老古董 Java 程序员认为，C# 和 Java 一样都是纯面向对象语言（Pure OOP），这是完全错误的。经过二十年的发展，C# 早已进化成一门多范式语言了。
函数式编程 那么如何用 C# 编写函数式代码呢？
回顾一下基础知识吧。
委托 Delegate 为了传递函数，C# 老早就加入了委托特性：
public delegate bool MyDelegateType (string first, string second); 在上面的代码中，我们创建了一个名为 MyDelegateType 的委托类型。
我们这样为委托赋值：
MyDelegateType myDel; myDel += &amp;lt;一些函数&amp;gt;; myDel(&amp;#34;first&amp;#34;, &amp;#34;second&amp;#34;); // 这样调用 匿名方法 Anonymous methods myDel = delegate (string first, string second) { return first.Length == second.</description>
    </item>
    
    <item>
      <title>Rx.NET 响应式编程指北 02 - 基本使用</title>
      <link>https://kyocius.github.io/posts/dotnet/reactive/rx-magic-2/</link>
      <pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://kyocius.github.io/posts/dotnet/reactive/rx-magic-2/</guid>
      <description>前言 在上一章里，我们学习了响应式的基本概念。在这一章节，我们将编写一个股票监控程序。首先我们将使用传统的 .NET 事件系统来写一次，之后再通过 Rx 来重构。
传统事件写法 先编写一个类，其中只有一个事件属性： class StockTicker { public event EventHandler&amp;lt;StockTick&amp;gt; StockTick; } 编写一个类包含我们的数据： class StockTick { public string QuoteSymbol { get; set; } public decimal Price { get; set; } } 创建一个类来监听变化，并订阅事件： class StockMonitor { public StockMonitor(StockTicker ticker) { ticker.StockTick += OnStockTick; // OnStockTick 注册事件 } ... } 因为我们需要比较股票价格的变化，所以我们可以通过字典来存储先前的股票数据。编写一个新类： class StockInfo { public StockInfo(string symbol, decimal price) { Symbol = symbol; PrevPrice = price; } public string Symbol { get; set; } public decimal PrevPrice { get; set; } } 之后你可以在 StockMonitor 中声明一个 StockInfo 类型的属性。</description>
    </item>
    
    <item>
      <title>Rx.NET 响应式编程指北 01 - 基础概念</title>
      <link>https://kyocius.github.io/posts/dotnet/reactive/rx-magic-1/</link>
      <pubDate>Sun, 07 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://kyocius.github.io/posts/dotnet/reactive/rx-magic-1/</guid>
      <description>前言 最近刚读了 Rx.NET in Action，学到的新概念非常多，担忧自己会日渐遗忘，觉得有必要写一篇博客记录一下，说不定也能帮到一些志同道合的朋友。
本系列将会使用我深爱的 C# 语言和 Rx.NET 框架来讲解响应式编程（Reactive Programming）的魔法 ╰(°▽°)╯
背景知识 C# 中的委托、泛型、事件以及 LINQ 等概念 Rx = Reactive Extension Rx 是由微软旗下一个实验室发起的 巨硬大法好 响应式概念 Rx 到底是干啥的？
首先来看看微软的解释：Rx = Observables + LINQ + Schedulers。谔谔，啥玩意儿？
那看看大佬怎么解释的吧：Rx = 处理异步数据流。这个解释还行，但还是不明白。
这里是更通俗的解释：
var a = 1; var b = 2; var c = a + b; // c 的值显然为 3 当你改变 a 或者 b 值的时候，按照我们以前的思维，c 的值并不会随之发生变化。
如果我们想要 c 的值随之而改变呢？很简单，快快使用 Rx！
可观察对象 Observable public interface IObservable&amp;lt;T&amp;gt; { IDisposable Subscribe(IObserver&amp;lt;T&amp;gt; observer); } 接口只有一个方法 Subscribe，返回 IDisposable 对象（代表着订阅事件本身） Observable 持有 Observer 的集合，在值改变时随时通知它们 IDisposable 对象可以通过 Dispose 方法随时取消订阅 观察者 Observer 观察者的源码其实也很简单。</description>
    </item>
    
  </channel>
</rss>
